<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Cpp网络通信01-基本的Socket通信</title>
    <link href="/2024/12/30/cpp/cpp-webserver02/"/>
    <url>/2024/12/30/cpp/cpp-webserver02/</url>
    
    <content type="html"><![CDATA[<h1 id="cpp网络通信02-基本的socket封装">Cpp网络通信02-基本的Socket封装</h1><h1 id="封装-tcpserver">封装 TcpServer</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TcpServer.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> Net &#123;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpServer</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int32_t</span> m_ListenFd;   <span class="hljs-comment">// 用于监听的socket，-1:未初始化</span><br>  <span class="hljs-type">int32_t</span> m_ClientFd;   <span class="hljs-comment">// 客户端连接上来的socket, -1:客户端未连接</span><br>  string m_ClientIp;<br>  <span class="hljs-type">uint16_t</span> m_Port;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">TcpServer</span>();<br>  ~<span class="hljs-built_in">TcpServer</span>();<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> inPort)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Accept</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; buffer)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Recv</span><span class="hljs-params">(string&amp; buffer, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> maxLen)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CloseClient</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">const</span> string&amp; <span class="hljs-title">GetClientIp</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_ClientIp; &#125;<br>&#125;;<br><br>&#125;<br><br><span class="hljs-comment">// TcpServer.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TcpServer.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> Net &#123;<br><br>TcpServer::<span class="hljs-built_in">TcpServer</span>()<br>: <span class="hljs-built_in">m_ListenFd</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">m_ClientFd</span>(<span class="hljs-number">-1</span>) &#123;&#125;<br><br>TcpServer::~<span class="hljs-built_in">TcpServer</span>() &#123;<br>  <span class="hljs-built_in">CloseClient</span>();<br>  <span class="hljs-built_in">Close</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TcpServer::Init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> inPort)</span> </span>&#123;<br>  <span class="hljs-comment">// 如果已经初始化(进入监听状态)，则直接返回失败</span><br>  <span class="hljs-keyword">if</span> (m_ListenFd != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// 1.创建服务端的socket</span><br>  <span class="hljs-comment">// AF_INET: ipv4    SOCK_STREAM: 流模式(TCP)</span><br>  m_Port = inPort;<br>  <br>  m_ListenFd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (m_ListenFd == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 2.把服务端用于通信的IP和端口绑定到socket上</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serverAddr;<br>  <span class="hljs-built_in">memset</span>(&amp;serverAddr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(serverAddr));<br>  serverAddr.sin_family = AF_INET; <span class="hljs-comment">// ipv4</span><br>  serverAddr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY); <span class="hljs-comment">// 表示接收所有地址的请求</span><br>  serverAddr.sin_port = <span class="hljs-built_in">htons</span>(m_Port); <span class="hljs-comment">// 服务器端口</span><br>  <span class="hljs-comment">// 绑定</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(m_ListenFd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;serverAddr, <span class="hljs-built_in">sizeof</span>(serverAddr)) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind&quot;</span>);<br>    <span class="hljs-built_in">close</span>(m_ListenFd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 3.把socket设置为监听状态</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(m_ListenFd, <span class="hljs-number">5</span>) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen&quot;</span>);<br>    <span class="hljs-built_in">close</span>(m_ListenFd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TcpServer::Accept</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 4.手里客户端的连接请求, accept是阻塞的</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> clientAddr; <span class="hljs-comment">// 客户端的地址信息</span><br>  <span class="hljs-type">socklen_t</span> addrLen = <span class="hljs-built_in">sizeof</span>(clientAddr);<br>  <br>  <span class="hljs-keyword">if</span> ((m_ClientFd = <span class="hljs-built_in">accept</span>(m_ListenFd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;clientAddr, &amp;addrLen)) == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  m_ClientIp = <span class="hljs-built_in">inet_ntoa</span>(clientAddr.sin_addr); <span class="hljs-comment">// 把客户端的地址从大端序转换成字符串</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TcpServer::Send</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; buffer)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (m_ClientFd == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">send</span>(m_ClientFd, buffer.<span class="hljs-built_in">data</span>(), buffer.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TcpServer::Recv</span><span class="hljs-params">(string&amp; buffer, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> maxLen)</span> </span>&#123;<br>  buffer.<span class="hljs-built_in">clear</span>();<br>  buffer.<span class="hljs-built_in">resize</span>(maxLen);<br>  <span class="hljs-type">int</span> n = <span class="hljs-built_in">recv</span>(m_ClientFd, &amp;buffer[<span class="hljs-number">0</span>], buffer.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span> ) &#123;<br>    buffer.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  buffer.<span class="hljs-built_in">resize</span>(n);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TcpServer::CloseClient</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (m_ClientFd == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-built_in">close</span>(m_ClientFd);<br>  m_ClientFd = <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TcpServer::Close</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (m_ListenFd == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-built_in">close</span>(m_ListenFd);<br>  m_ClientFd = <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="封装-tcpclient">封装 TcpClient</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TcpClient.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> Net &#123;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpClient</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int32_t</span> m_ClientFd;<br>  string m_Ip;<br>  <span class="hljs-type">uint16_t</span> m_Port;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">TcpClient</span>();<br>  ~<span class="hljs-built_in">TcpClient</span>();<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Connect</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; inIp, <span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> inPort)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; buffer)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Recv</span><span class="hljs-params">(string&amp; buffer, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> maxLen)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br>&#125;<br><br><span class="hljs-comment">// TcpClient.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TcpClient.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> Net &#123;<br><br>TcpClient::<span class="hljs-built_in">TcpClient</span>()<br>: <span class="hljs-built_in">m_ClientFd</span>(<span class="hljs-number">-1</span>) &#123;&#125;<br><br>TcpClient::~<span class="hljs-built_in">TcpClient</span>()<br>&#123;<br>  <span class="hljs-built_in">Close</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TcpClient::Connect</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; inIp, <span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> inPort)</span> </span>&#123;<br>  <span class="hljs-comment">// 如果已连接，直接失败</span><br>  <span class="hljs-keyword">if</span> (m_ClientFd != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  m_Ip = inIp;<br>  m_Port = inPort;<br><br>  <span class="hljs-comment">// 1.创建客户端的socket</span><br>  m_ClientFd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (m_ClientFd == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 2.向服务器发起连接请求</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hostent</span>* h; <span class="hljs-comment">// 用于存放服务端ip</span><br>  <span class="hljs-keyword">if</span> ((h = <span class="hljs-built_in">gethostbyname</span>(m_Ip.<span class="hljs-built_in">c_str</span>())) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">close</span>(m_ClientFd);<br>    m_ClientFd = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serverAddr;<br>  <span class="hljs-built_in">memset</span>(&amp;serverAddr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(serverAddr));<br>  serverAddr.sin_family = AF_INET;                      <span class="hljs-comment">// 协议族</span><br>  <span class="hljs-built_in">memcpy</span>(&amp;serverAddr.sin_addr, h-&gt;h_addr, h-&gt;h_length); <span class="hljs-comment">// IP地址</span><br>  serverAddr.sin_port = <span class="hljs-built_in">htons</span>(m_Port);                  <span class="hljs-comment">// 端口</span><br>  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(m_ClientFd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;serverAddr, <span class="hljs-built_in">sizeof</span>(serverAddr)) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TcpClient::Send</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; buffer)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (m_ClientFd == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">send</span>(m_ClientFd, buffer.<span class="hljs-built_in">data</span>(), buffer.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TcpClient::Recv</span><span class="hljs-params">(string&amp; buffer, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> maxLen)</span> </span>&#123;<br>  buffer.<span class="hljs-built_in">clear</span>();<br>  buffer.<span class="hljs-built_in">resize</span>(maxLen);<br>  <span class="hljs-type">int</span> n = <span class="hljs-built_in">recv</span>(m_ClientFd, &amp;buffer[<span class="hljs-number">0</span>], buffer.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span> ) &#123;<br>    buffer.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  buffer.<span class="hljs-built_in">resize</span>(n);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TcpClient::Close</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (m_ClientFd == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-built_in">close</span>(m_ClientFd);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="使用">使用</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Server.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;network/TcpServer.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br><br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:\n\tServer &lt;port&gt;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 创建服务端实例</span><br>  Net::TcpServer server;<br>  <br>  <span class="hljs-comment">// 初始化服务端，并开始监听端口</span><br>  <span class="hljs-keyword">if</span> (!server.<span class="hljs-built_in">Init</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]))) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;TcpServer::Init()&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;服务器端口: &quot;</span> &lt;&lt; argv[<span class="hljs-number">1</span>] &lt;&lt; endl;<br><br>  <span class="hljs-comment">// 服务端开始受理客户端连接</span><br>  <span class="hljs-keyword">if</span> (!server.<span class="hljs-built_in">Accept</span>()) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;TcpServer::Accept()&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;客户端已连接: &quot;</span> &lt;&lt; server.<span class="hljs-built_in">GetClientIp</span>() &lt;&lt; endl;<br><br>  string buffer;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 接收对端的报文</span><br>    <span class="hljs-keyword">if</span> (!server.<span class="hljs-built_in">Recv</span>(buffer, <span class="hljs-number">1024</span>)) &#123;<br>      <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;TcpServer::Recv()&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;接收: &quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br><br>    buffer = <span class="hljs-string">&quot;ok&quot;</span>;<br><br>    <span class="hljs-keyword">if</span> (!server.<span class="hljs-built_in">Send</span>(buffer)) &#123;<br>      <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;TcpServer::Send()&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;发送: &quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br><span class="hljs-comment">// Client.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;network/TcpClient.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br><br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Usage:\n\t./Client &lt;服务端IP&gt; &lt;服务端端口&gt;\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  Net::TcpClient client;<br><br>  <span class="hljs-keyword">if</span> (!client.<span class="hljs-built_in">Connect</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]))) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;TcpClient::Connect()&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br><br>  <span class="hljs-comment">// 3.与服务器通信，发送一个请求报文后等待回复，然后再发下一个报文</span><br>  string buffer;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    buffer = <span class="hljs-string">&quot;这是第&quot;</span> + <span class="hljs-built_in">to_string</span>(i+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;条报文&quot;</span>;<br><br>    <span class="hljs-keyword">if</span> (!client.<span class="hljs-built_in">Send</span>(buffer)) &#123;<br>      <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;TcpClient::Send()&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;发送: &quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 接收服务端的回应，recv会阻塞</span><br>    <span class="hljs-keyword">if</span> (!client.<span class="hljs-built_in">Recv</span>(buffer, <span class="hljs-number">1024</span>)) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;接收: &quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>network</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp网络通信01-基本的Socket通信</title>
    <link href="/2024/12/29/cpp/cpp-webserver01/"/>
    <url>/2024/12/29/cpp/cpp-webserver01/</url>
    
    <content type="html"><![CDATA[<h1 id="cpp网络通信01-基本的socket通信">Cpp网络通信01-基本的Socket通信</h1><h2 id="服务端代码">服务端代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:\n\t./Server &lt;服务端端口&gt;\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello Server!\n&quot;</span>);<br>  <br>    <span class="hljs-comment">// 1.创建服务端的socket</span><br>    <span class="hljs-comment">// AF_INET: ipv4    SOCK_STREAM: 流模式(TCP)</span><br>    <span class="hljs-type">int</span> listenFd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (listenFd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 2.把服务端用于通信的IP和端口绑定到socket上</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serverAddr;<br>    <span class="hljs-built_in">memset</span>(&amp;serverAddr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(serverAddr));<br>    serverAddr.sin_family = AF_INET; <span class="hljs-comment">// ipv4</span><br>    serverAddr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY); <span class="hljs-comment">// 表示接收所有地址的请求</span><br>    serverAddr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>])); <span class="hljs-comment">// 服务器端口</span><br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(listenFd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;serverAddr, <span class="hljs-built_in">sizeof</span>(serverAddr)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-built_in">close</span>(listenFd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3.把socket设置为监听状态</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(listenFd, <span class="hljs-number">5</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-built_in">close</span>(listenFd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;监听端口: &quot;</span> &lt;&lt; argv[<span class="hljs-number">1</span>] &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 4.手里客户端的连接请求, accept是阻塞的</span><br>    <span class="hljs-type">int</span> clientFd = <span class="hljs-built_in">accept</span>(listenFd, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (clientFd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept&quot;</span>);<br>        <span class="hljs-built_in">close</span>(listenFd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;客户端已连接\n&quot;</span>;<br><br>    <span class="hljs-comment">// 5.与客户端通信，接收客户端发过来的报文后，回复ok.</span><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> iret;<br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br>        <span class="hljs-comment">// 接收客户端的请求报文，recv同样是阻塞的</span><br>        <span class="hljs-comment">// 如果客户端断开连接，recv()返回0</span><br>        <span class="hljs-keyword">if</span> ((iret = <span class="hljs-built_in">recv</span>(clientFd, buffer, <span class="hljs-built_in">sizeof</span>(buffer), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;iret=&quot;</span> &lt;&lt; iret &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;接收: &quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br><br>        <span class="hljs-built_in">strcpy</span>(buffer, <span class="hljs-string">&quot;ok&quot;</span>); <span class="hljs-comment">// 生成回应报文</span><br>        <span class="hljs-comment">// 向客户端发送回应报文</span><br>        <span class="hljs-keyword">if</span> ((iret = <span class="hljs-built_in">send</span>(clientFd, buffer, <span class="hljs-built_in">strlen</span>(buffer), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;send&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;发送: &quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 6.关闭socket</span><br>    <span class="hljs-built_in">close</span>(listenFd);<br>    <span class="hljs-built_in">close</span>(clientFd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="客户端代码">客户端代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Usage:\n\t./Client &lt;服务端IP&gt; &lt;服务端端口&gt;\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;连接到 &quot;</span> &lt;&lt; argv[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; argv[<span class="hljs-number">2</span>] &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 1.创建客户端的socket</span><br>    <span class="hljs-type">int</span> socketFd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (socketFd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 2.向服务器发起连接请求</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hostent</span>* h; <span class="hljs-comment">// 用于存放服务端ip</span><br>    <span class="hljs-keyword">if</span> ((h = <span class="hljs-built_in">gethostbyname</span>(argv[<span class="hljs-number">1</span>])) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;gethostbyname&quot;</span>);<br>        <span class="hljs-built_in">close</span>(socketFd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serverAddr;<br>    <span class="hljs-built_in">memset</span>(&amp;serverAddr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(serverAddr));<br>    serverAddr.sin_family = AF_INET;<br>    <span class="hljs-built_in">memcpy</span>(&amp;serverAddr.sin_addr, h-&gt;h_addr, h-&gt;h_length);<br>    serverAddr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(socketFd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;serverAddr, <span class="hljs-built_in">sizeof</span>(serverAddr)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;connect&quot;</span>);<br>        <span class="hljs-built_in">close</span>(socketFd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 3.与服务器通信，发送一个请求报文后等待回复，然后再发下一个报文</span><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-type">int</span> iret;<br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br>        <span class="hljs-built_in">sprintf</span>(buffer, <span class="hljs-string">&quot;这是第%d条报文&quot;</span>, i + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">if</span> ((iret = <span class="hljs-built_in">send</span>(socketFd, buffer, <span class="hljs-built_in">strlen</span>(buffer), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;send&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;发送: &quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br><br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br>        <span class="hljs-comment">// 接收服务端的回应，recv会阻塞</span><br>        <span class="hljs-keyword">if</span> ((iret = <span class="hljs-built_in">recv</span>(socketFd, buffer, <span class="hljs-built_in">sizeof</span>(buffer), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;iret=&quot;</span> &lt;&lt; iret &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;接收: &quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 4.关闭socket</span><br>    <span class="hljs-built_in">close</span>(socketFd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>network</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++17将const char*处理为中文路径的方法</title>
    <link href="/2024/10/31/cpp/cpp-20241031/"/>
    <url>/2024/10/31/cpp/cpp-20241031/</url>
    
    <content type="html"><![CDATA[<p>使用 <code>glfwSetDropCallback</code> 的过程中遇到了中文乱码问题，需要将const char*转换为中文路径</p><p>可以使用 C++ 标准库的 <code>std::filesystem</code>，它支持 UTF-8 编码，允许跨平台处理带有中文字符的文件路径。这种方法不依赖特定平台 API，能够在多平台上正常处理中文字符。</p><p>以下是使用 <code>std::filesystem::path</code> 处理 GLFW 中文路径的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> fs = std::filesystem;<br><br><span class="hljs-comment">// 回调函数，处理文件拖放事件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dropCallback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span>** paths)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-comment">// 将 UTF-8 编码的 char* 转换为 std::filesystem::path</span><br>        fs::path filePath = fs::<span class="hljs-built_in">u8path</span>(paths[i]);<br><br>        <span class="hljs-comment">// 打印路径，可以使用 native() 来获取平台适配的字符串</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;文件路径: &quot;</span> &lt;&lt; filePath.<span class="hljs-built_in">u8string</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">glfwInit</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    GLFWwindow* window = <span class="hljs-built_in">glfwCreateWindow</span>(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-string">&quot;GLFW Drop Callback&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (!window) &#123;<br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">glfwMakeContextCurrent</span>(window);<br><br>    <span class="hljs-comment">// 设置文件拖放回调</span><br>    <span class="hljs-built_in">glfwSetDropCallback</span>(window, dropCallback);<br><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(window)) &#123;<br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">glfwDestroyWindow</span>(window);<br>    <span class="hljs-built_in">glfwTerminate</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo常用命令</title>
    <link href="/2024/10/31/hexo-20241031/"/>
    <url>/2024/10/31/hexo-20241031/</url>
    
    <content type="html"><![CDATA[<h3 id="hexo-init">1、hexo init</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo init 命令用于初始化一个本地文件夹为网站的根目录</span><br></code></pre></td></tr></table></figure><h3 id="hexo-new">2、hexo new</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo new title 新建一篇文章</span><br></code></pre></td></tr></table></figure><h3 id="hexo-generate">3、hexo generate</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo generate 可以简写成 hexo g</span><br>该命令用于生成静态文件<br></code></pre></td></tr></table></figure><h3 id="hexo-server">4、hexo server</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo server 命令用于启动本地服务器，一般可以简写成 hexo s</span><br></code></pre></td></tr></table></figure><p>可以加一些参数 -p 选项，指定服务器端口，默认为 4000 -i 选项，指定服务器 IP 地址，默认为 0.0.0.0 -s 选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视</p><h3 id="hexo-deploy">5、hexo deploy</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo deploy 命令用于部署网站，一般可以简写成 hexo d</span><br></code></pre></td></tr></table></figure><h3 id="hexo-clean">6、hexo clean</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo clean 命令用于清理缓存文件，是一个比较常用的命令</span><br></code></pre></td></tr></table></figure><h3 id="hexo---safe">7、hexo --safe</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo --safe 表示安全模式，用于禁用加载插件和脚本</span><br></code></pre></td></tr></table></figure><h3 id="hexo---debug">8、hexo --debug</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo --debug 表示调试模式，用于将消息详细记录到终端和 debug.log 文件</span><br></code></pre></td></tr></table></figure><h3 id="hexo---silent">9、hexo --silent</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo --silent  表示静默模式，用于静默输出到终端</span><br></code></pre></td></tr></table></figure><p>————————————————</p><p>原文链接：https://blog.csdn.net/weixin_43720067/article/details/115917421</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人机交互期末复习</title>
    <link href="/2023/06/06/note-20230606/"/>
    <url>/2023/06/06/note-20230606/</url>
    
    <content type="html"><![CDATA[<h2 id="绪论">绪论</h2><h3 id="什么是人机交互">什么是人机交互</h3><p>人机交互（HCI:human computer interaction）是指<strong>关于设计、评价和实现供人们使用的交互式计算机系统，并围绕相关的主要现象进行研究的学科。</strong></p><h3 id="人机交互和软件工程的区别与联系">人机交互和软件工程的区别与联系</h3><p>从人机交互工程师（用户视角）和软件工程师（技术角度）的角度来看，人机交互与软件工程在设计上有以下不同观点：</p><ol type="1"><li><strong>需求分析</strong>：<ul><li>人机交互工程师：注重用户需求和期望。他们关注用户如何与系统交互，用户的行为模式，用户的心理模型等。他们通过用户研究、用户调查和用户测试等方法来理解用户需求，并将这些需求转化为可用性要求和界面设计指导。</li><li>软件工程师：注重系统功能和技术实现。他们关注软件系统的功能需求、数据处理和算法等。他们通过与领域专家和业务分析师合作，以及使用需求工程技术来定义和规划系统功能。</li></ul></li><li><strong>软件设计</strong>：<ul><li>人机交互工程师：关注用户体验和界面设计。他们着重于设计用户界面，包括布局、交互元素、导航结构等，以提供直观、易用和满足用户期望的界面。他们通常使用用户中心的设计方法，如人机交互原型、用户故事板等。</li><li>软件工程师：关注系统架构和模块设计。他们考虑软件系统的结构、组件和模块之间的关系，并设计合适的软件架构以实现系统的功能需求。他们通常使用面向对象设计、设计模式等技术来构建可维护和可扩展的软件。</li></ul></li><li><strong>评估方式</strong>：<ul><li>人机交互工程师：注重用户反馈和用户测试。他们通过用户测试、用户调查、用户观察等方法来评估界面的可用性和用户满意度。他们关注用户在使用界面时的反应和行为，并根据这些反馈来改进设计。</li><li>软件工程师：注重功能测试和性能测试。他们通过单元测试、集成测试和系统测试等方法来评估软件的功能是否符合需求，以及性能是否满足要求。他们关注软件系统的正确性、可靠性和效率等方面。</li></ul></li></ol><p>综上所述，人机交互工程师和软件工程师在需求分析、软件设计和评估方式等方面有不同的观点。人机交互工程师着重于用户需求和体验，关注用户界面的设计和用户反馈；而软件工程师则注重系统功能和技术实现，关注软件系统的架构和功能实现。</p><table><thead><tr class="header"><th></th><th>人机交互工程师（用户视角）</th><th>软件工程师（技术角度）</th></tr></thead><tbody><tr class="odd"><td>需求分析</td><td>注重<strong>用户</strong>需求和期望</td><td>注重<strong>系统</strong>功能和技术实现</td></tr><tr class="even"><td>软件设计</td><td>关注<strong>用户</strong>体验和界面设计</td><td>关注<strong>系统</strong>架构和模块设计</td></tr><tr class="odd"><td>评估方式</td><td>注重<strong>用户</strong>反馈和用户测试</td><td>注重<strong>系统</strong>功能和性能测试</td></tr></tbody></table><h2 id="第一章">第一章</h2><h3 id="可用性">可用性</h3><p>关于交互系统的可用性，国际标准化组织（ISO）在其 ISO FDIS9241-11 标准（Guidance onUsability 1997）中认为可用性是指当用户在特定的环境中使用产品完成具体任务时交互过程的有效性、交互效率和用户满意度。</p><div class="note note-info">            <ul><li><p><strong>有效性</strong>：用户完成特定任务和达到特定目标时所具有的正确和完整程度</p></li><li><p><strong>效率</strong>：用户完成任务的正确和完整程度与所使用资源（如时间）之间的比率</p></li><li><p><strong>用户主观满意度</strong>：用户在使用产品过程中所感受到的主观满意和接受程度</p></li></ul>          </div><p>交互设计领域有丰富的理论沉淀，最著名和经典的理论当属人机交互大师雅各布·尼尔森（Jakob Nielsen）博士在 1995 提出的尼尔森十大可用性原则（Jakob Nielsen’s Ten UsabilityHeuristics），该理论是针对 PC 端交互设计提出的，但同时也适用于移动端交互设计。</p><h3 id="可用性度量">可用性度量</h3><ol type="1"><li>学习时间</li><li>运行速度</li><li>用户出错率</li><li>记忆保持时间</li><li>主观满意度</li></ol><h3 id="支持可用性的设计原则">支持可用性的设计原则</h3><h4 id="可学习性">可学习性</h4><ul><li>可预见性</li><li>同步性</li><li>熟悉性</li><li>通用性</li><li>一致性</li></ul><h4 id="灵活性">灵活性</h4><ul><li>可定制性</li><li>对话主动性</li><li>多线程</li><li>可互换性</li><li>可替换性</li></ul><h4 id="鲁棒性">鲁棒性</h4><ul><li>任务规范性</li><li>可观察性</li><li>响应性</li><li>可回复性</li></ul><h2 id="第二章">第二章</h2><h3 id="通用性目标">通用性目标</h3><blockquote><p><strong>满足所有用户的需求</strong></p></blockquote><h3 id="针对设计特征如何设计">针对设计（特征，如何设计）</h3><p>三个典型的用户：残疾 老年 儿童</p><ol type="1"><li><strong>残疾用户</strong><ul><li>视觉障碍者(文本转成语言)，听觉障碍者（语音转文本），身体障碍(语言输入设备、人眼凝视技术等)</li><li>用脑机接口等高科技手段，帮助高度残疾或者其他特殊人群（比如渐冻症患者）使用计算机。</li></ul></li><li><strong>老年用户</strong><ul><li>界面使用更大的字体，更明显的图标，提高音量，方便老年用户进行操作。</li><li>减少动画的干扰，增加界面的色彩饱和度。</li><li>包含语音交互的模式，降低操作精度，减少老年用户的点触。</li></ul></li><li><strong>儿童用户</strong><ul><li>降低操作精度，减少精确的操作，比如区域化选择对象、时效性拖动对象等操作，从而提升儿童用户的体验乐趣。</li><li>更多的使用形象化的、生活化的图形界面设计，减少同一化的、相似的、抽象的概念图形，让界面对儿童用户更加有吸引力。</li><li>简化应用流程，降低应用程序逻辑的复杂度。</li></ul></li></ol><h2 id="第三章">第三章</h2><h3 id="什么是指南">什么是指南</h3><p><strong>指南</strong>（Guidelines）是基于研究和实践经验，为设计师提供的关于设计和交互的建议和准则。它们旨在帮助设计师设计出<strong>易用、可访问和符合用户期望的界面</strong>。</p><h4 id="三个常用的指南">三个常用的指南</h4><ol type="1"><li><p><strong>用户界面设计指南</strong>：这些指南侧重于界面设计的方面，包括布局、颜色、图标、字体等。它们提供了关于用户界面设计的准则，以确保用户界面的一致性、可用性和可理解性。</p></li><li><p><strong>交互设计指南</strong>：这些指南关注用户与界面的交互方式，包括操作流程、交互元素的行为和反馈等。它们提供了设计交互行为和动画、用户输入和操作的准则，以增强用户体验和界面的可操作性。</p></li><li><p><strong>可访问性指南</strong>：这些指南旨在确保用户界面对于各种能力水平和使用辅助技术的用户都可访问。它们提供了设计和实施无障碍功能的准则，如可访问的标记语言、键盘导航、视觉辅助等。</p></li></ol><h4 id="四个具体的指南">四个具体的指南</h4><ol type="1"><li><p><strong>苹果人机界面指南</strong>：这是苹果公司为开发iOS和macOS应用程序的设计师提供的指南。它包含了关于用户界面、交互和设计的准则，帮助设计师构建与苹果平台一致且符合用户期望的应用程序。</p></li><li><p><strong>谷歌材料设计指南</strong>：这是谷歌为开发Android应用程序和Web应用程序的设计师提供的指南。它提供了关于界面设计、交互模式、动画效果等方面的准则，以创建具有谷歌风格的现代化应用程序。</p></li><li><p><strong>微软用户体验指南</strong>：这是微软为开发Windows应用程序的设计师提供的指南。它包含了关于界面设计、交互模式、可访问性和多语言支持等方面的准则，以确保应用程序在Windows平台上具有良好的用户体验。</p></li><li><p><strong>W3C Web内容可访问性指南</strong>：这是由万维网联盟（W3C）制定的一套关于Web内容可访问性的指南。它提供了关于Web内容的可访问性准则，以确保Web页面和应用程序对于不同能力的用户都可访问。这些指南涵盖了标记语言、媒体、表单、键盘导航等方面的要求。</p></li></ol><h3 id="界面设计8条黄金法则">界面设计8条黄金法则</h3><ol type="1"><li>坚持<strong>一致性</strong>。</li><li>常用操作要有<strong>快捷方式</strong>。</li><li>提供信息<strong>反馈</strong>（告知状态及操作）。</li><li>设计<strong>对话框</strong>产生结束信息（反馈结果）。</li><li><strong>预防</strong>错误（避免用户犯错）。</li><li>提供<strong>回退</strong>操作。</li><li>用户掌握<strong>控制权</strong>（给予用户选择的权力）。</li><li>减少短期<strong>记忆</strong>负担。</li></ol><h3 id="图形用户界面的3个思想">图形用户界面的3个思想</h3><ol type="1"><li><strong>桌面隐喻</strong></li><li><strong>所见即所得</strong></li><li><strong>直接操纵</strong> &gt;直接操纵是指可以把操作的对象、属性、关系显式地表示出来，用光笔、鼠标、触摸屏或数据手套等指点设备直接从屏幕上获取形象化命令与数据的过程。</li></ol><h3 id="种交互风格">5种交互风格</h3><ol type="1"><li>直接操作</li><li>菜单选择</li><li>表单填写</li><li>命令语言</li><li>自然语言</li></ol><figure><img src="/img/post/20230606/1.png" alt="" /><figcaption>五种交互风格</figcaption></figure><h2 id="第四章">第四章</h2><h3 id="设计进程大题">设计进程（大题）</h3><ol type="1"><li>（用户）需求分析</li><li>概要和详细设计</li><li>构造与实施</li><li>评估</li></ol><h3 id="任务分析必考">任务分析（必考）</h3><ol type="1"><li><strong>使用行为分析</strong><ul><li>要理解系统中<strong>每个参与者及其所需完成的任务</strong>，一般使用<strong>用例图</strong>描述 <img src="/img/post/20230606/2.png" alt="使用行为分析" /></li></ul></li><li><strong>顺序分析</strong><ul><li>每个使用行为都是由若干步骤组成的，这些步骤可以使用<strong>顺序图</strong>进行描述</li><li><strong>用例常常被细化为一个或更多的顺序图</strong> <img src="/img/post/20230606/3.png" alt="顺序分析" /></li></ul></li><li><strong>协作关系分析</strong><ul><li>注重某个<strong>用户行为中各个系统元素之间的关系</strong>，而不再重点强调各个步骤的时间顺序。 <img src="/img/post/20230606/4.png" alt="协作关系分析" /></li></ul></li></ol><h3 id="设计框架三种设计">设计框架（三种设计）</h3><ol type="1"><li><strong>以用户为中心的设计</strong> (UCD)<ul><li>在设计过程的每个设计阶段都考虑到最终用户的需求、想法和局限性。</li><li><strong>四大原则</strong><ol type="1"><li><strong>及早以用户为中心：</strong> 设计人员应当在设计过程的早期就致力于了解用户的需要。</li><li><strong>综合设计：</strong> 设计的所有方面应当齐头并进发展，而不是顺次发展，使产品的内部设计与用户界面的需要始终保持一致。</li><li><strong>及早并持续性地进行测试：</strong> 当前对软件测试的唯一可行的方法是根据经验总结出的方法，即若实际用户认为设计是可行的，它就是可行的。通过在开发的全过程引入可用性测试，可以使用户有机会在产品推出之前就设计提供反馈意见。</li><li><strong>反复式设计：</strong> 大问题往往会掩盖小问题的存在。设计人员和开发人员应当在整个测试过程中反复对设计进行修改。</li></ol></li></ul></li><li><strong>参与式设计</strong> (PD)<ul><li>人们直接参与到他们所用产品和技术的协同设计中。</li></ul></li><li><strong>敏捷交互设计</strong><ul><li>表示一类适用于团队开发的方法，目的是确保灵活性、适应性，并快速对不断变化的需求做出快速反应，并以<u>渐进式开发</u>为基础。</li></ul></li></ol><h2 id="第五章">第五章</h2><h3 id="专家评审和启发式方法概念方法">专家评审和启发式方法（概念，方法）</h3><h4 id="启发式">启发式</h4><p>以一种快速的看起来不费力的方式做复杂的决定或进行推论时应用的一些简单规则。</p><p><strong>启发性评估的两大原则</strong></p><ol type="1"><li>不能是设计师本人</li><li>具有可用性知识</li></ol><p><strong>优缺点</strong> 优点：成本低、效率高、可以发现大多数可用性问题。 缺点：不能代表真实用户、比较主观；有时发现问题过多；对评估者的要求较高。</p><h4 id="专家评审">专家评审</h4><p>以专家为索取未来信息的对象，组织各领域的专家运用专业方面的知识和经验，通过直观的归纳，对预测对象过去和现在的状况、发展变化过程进行综合分析与研究，找出预测对象变化、发展规律、从而对预测对象未来的发展与实际状况做出判断。</p><p><strong>流程</strong>：使用某种方法，遍历界面中的所有功能，在较短时间内给出评审结果，通常是一份正式报告书。</p><h3 id="可用性评估方法诊查测试式方法">可用性评估方法（诊查、测试式方法）</h3><ol type="1"><li><strong>诊察式</strong><ul><li><strong>(1) 用户模型法</strong> 基于用户模型来评估界面的可用性。评估者通过分析用户的特征、目标、需求和行为模式，识别潜在的设计问题和改进机会。</li><li><strong>(2) 启发式评估</strong> 由专家评估界面设计并应用启发式评估原则，如Nielsen的十项启发式评估，以识别潜在的设计问题和改进点。</li><li><strong>(3) 认知性遍历</strong> 评估者按照用户的认知过程，逐步浏览界面并考虑用户可能的行为和决策，以评估界面的可用性和用户体验。</li></ul></li><li><strong>测试式</strong><ul><li><strong>(1) 用户测试</strong> 让真实用户执行特定任务或场景，通过观察和记录他们的行为、反应和问题，来评估界面的易用性和用户体验。</li><li><strong>(2) 问卷调查</strong> 让真实用户执行特定任务或场景，通过观察和记录他们的行为、反应和问题，来评估界面的易用性和用户体验。</li><li><strong>(3) 放声思考法</strong> 让真实用户执行特定任务或场景，通过观察和记录他们的行为、反应和问题，来评估界面的易用性和用户体验。</li><li><strong>(4) 访谈法</strong> 与用户进行面对面或远程访谈，通过提问和讨论的方式，深入了解他们的需求、期望和体验，以评估界面的可用性和用户满意度。</li></ul></li></ol><h2 id="第六章">第六章</h2><h3 id="敏捷交互设计过程">敏捷交互设计(过程)</h3><p>敏捷设计以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发在敏捷设计中，软件项目在构建初期被切分成多个<strong>子项目</strong>，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系但也可独立运行的小项目，并分别完成。在此过程中，<strong>软件一直处于可使用状态</strong></p><ol type="1"><li><strong>快速迭代</strong>。相对那种半年一次的大版本发布来说，<strong>小版本</strong>的需求、开发和测试更加简单快速</li><li><strong>让测试人员和开发者参与需求讨论</strong>。需求讨论以研讨组的形式展开最有效率，需要包括测试人员和开发者。这样可以更加轻松地定义可测试的需求，<strong>将需求分组并确定优先级</strong>。同时，该种方式也可以充分利用团队成员间的互补特性。</li><li><strong>编写可测试的需求文档</strong>。开始就要用“用户故事”的方法来编写需求文档。这样可以将注意力放在需求上，而不是解决方法和实施技术上。过早的提及技术实施方案会降低对需求的注意力。</li><li><strong>多沟通，尽量减少文档</strong>。在任何项目中，沟通都是一个常见的问题。好的沟通是敏捷开发的先决条件。在圈子里面呆得越久，越会强调良好高效的沟通的重要性。团队要确保日常的交流，面对面沟通比邮件强得多</li><li><strong>做好产品原型</strong>。建议使用<strong>草图和模型</strong>来阐明用户界面。并不是所有人都可以理解一份复杂的文档，但人人都会看图</li><li><strong>及早考虑测试</strong>。这在敏捷开发中很重要。在传统的软件开发中，很晚才开始写测试用例，这导致过晚发现需求中存在的问题，提高改进成本。<strong>较早地开始编写测试用例</strong>，这样当需求完成时，可以接受的测试用例也基本起完成了。</li></ol><h2 id="第七章">第七章</h2><h3 id="什么是直接操纵">什么是直接操纵</h3><p>指用户通过<strong>直接操作界面上的对象或元素</strong>来执行任务或操作的一种交互方式。用户可以通过手势、鼠标、触摸屏等方式与界面中的对象进行实时互动，<strong>直接看到操作结果的变化</strong>。</p><h3 id="直接操纵的特点">直接操纵的特点</h3><ol type="1"><li>是真实世界的扩展</li><li>操纵对象可见</li><li>可以增量操作 可看见前一个操作的结果，任务的进展是持续的</li><li>操作可逆 更方便地撤销错误的操作</li></ol><h3 id="直接操纵的平移距离强中弱的例子">直接操纵的平移距离（强中弱的例子）</h3><p><strong>直接操纵的平移距离</strong>：用户与隐喻的表现之间的平移距离，即<strong>隐喻的强度</strong></p><ul><li>强度可以通过从“弱”到“沉浸式”的过渡</li><li>还可进一步将其描述为<u>用户的身体动作</u>和<u>虚拟空间中的动作</u>之间的间接性水平</li><li>例子<ol type="1"><li><strong>弱</strong>：早期的电子游戏控制器。</li><li><strong>中等</strong>：触摸屏，多点触摸。</li><li><strong>强</strong>：数据手套，手势，操纵实物。</li><li><strong>沉浸式</strong>：虚拟现实，如头戴式显示器。</li></ol></li></ul><h3 id="直接操纵优缺点">直接操纵优缺点</h3><h4 id="优点">优点</h4><ul><li>形象化地呈现任务概念</li><li>允许简单地学习</li><li>允许简单地记忆</li><li>允许避免错误</li><li>鼓励探索</li><li>提供较高的主观满意度</li></ul><h4 id="缺点">缺点</h4><ul><li>可能很难编写程序</li><li>需要特别注意可达性</li></ul><h3 id="什么是虚拟现实和增强现实">什么是虚拟现实和增强现实</h3><ul><li><strong>虚拟现实</strong>的远程呈现打破了空间限制，使得用户认为身处他处。 <div class="note note-info">            <p>举例：虚拟现实可在外科医生或他们的助手进行手术时提供帮助，它能显示相关的手术信息，并在真实世界中显示</p>          </div></li><li><strong>增强现实</strong>可以使用户看到叠加了附加信息的现实世界。 <div class="note note-info">            <p>举例：使用增强现实叠加图，可以在手机上显示不同的感兴趣的热点，使用图标代表位置类型(食品、购物等)及与当前位置的距离。</p>          </div></li></ul><h2 id="第八章">第八章</h2><h3 id="导航种类">导航种类</h3><ol type="1"><li>菜单栏，弹出菜单，工具栏，面板和功能区</li><li>快捷方式和快速交互手势</li><li>长列表</li><li>序列菜单与同步菜单</li></ol><h3 id="内容组织">内容组织</h3><p>要对有意义的菜单项来分组和排序，精心编辑标题和标签，适当的设计布局，可以缩短选择时间，提高用户满意度。</p><ol type="1"><li><p><strong>线性序列</strong>：按单一方向</p></li><li><p><strong>层次结构</strong>：按照层级划分多个级别</p><p><strong>菜单树</strong>的形成规则:</p><ul><li>用<strong>任务语义</strong>组织菜单</li><li><strong>限制层级数</strong>(例如，宁愿广而浅，而不窄而深)</li><li>创建<strong>逻辑上相似</strong>的选项组：例如，级别1:国家，级别2:州，级别3:城市</li><li>形成<strong>涵盖所有可能性</strong>的选项组：例如年龄范围:[0-9][10-19][20-29]和[&gt;= 30]</li><li>保证<strong>选项不重叠</strong>，例如：用“音乐”和“运动”分类。而不用”娱乐”和“事件”分类</li><li>在每个分支上<strong>自然顺列</strong>项目(不按字母)，或将相关项目分为一组。按<u>使用频率</u>排序菜单项比按类别或字母顺序排序更有用。</li><li>保持各项的<strong>顺序固定</strong>(否则在菜单的专用部分可能出现重复的频繁项)</li></ul></li><li><p><strong>网络结构</strong>：可以通过多个路径(例如网站)到达</p></li></ol><div class="note note-info">            <ul><li>对于层次结构，菜单广度优先比深度优先更好，即通过增加宽度来减少深度操作。 因为深度增加会导致导航的不可测和不稳定性。但也要同时考虑屏幕空间的限制。</li><li>排版的<strong>四个原则</strong>： 亲密性，对齐，重复，对比</li></ul>          </div><h2 id="第九章">第九章</h2><h3 id="语音识别概念">语音识别（概念）</h3><p>语音识别（ASR，Automatic Speech Recognition），就是将人的语音转换为机器可以识别并理解的文本或命令的过程。</p><ul><li><strong>语音输入</strong>：语音生成文本（快速录入、字幕自动生成、专业词汇更正）</li><li><strong>语音命令</strong>：有效识别某些命令（语音助手）</li><li><strong>对话翻译</strong></li></ul><h3 id="口语交互优缺点及障碍">口语交互优缺点及障碍</h3><h4 id="应用人群及场景">应用人群及场景</h4><ul><li>残疾用户、无法进行读写的用户(如儿童)</li><li>腾不出手的说话者</li><li>不断移动的人员</li><li>妨碍键盘使用的恶劣或狭小环境</li><li>词汇和任务有限的应用领域</li></ul><h4 id="优点-1">优点</h4><ul><li><strong>比打字快</strong>：听写比打字快，对用户来说更方便。</li><li><strong>易用性</strong>：并非所有人都能很好地使用技术设备。但任何用户都可以使 用语音向VUI设备或AI助手请求任务。</li><li><strong>免提</strong>：在某些情况下，例如开车、做饭或当你远离设备时，说话比打 字或敲击要实用得多。</li><li><strong>免视</strong>：VUI 提供免视用户体验。在驾驶等情况下，你可以专注于道路 而不是设备。它对于屏幕疲劳问题也很实用。</li></ul><h4 id="缺点-1">缺点</h4><ul><li>嘈杂环境和劣质麦克风的<strong>干扰</strong></li><li>命令需要<strong>学习和记忆</strong></li><li>强烈的口音或不正常的词汇表会对<strong>识别</strong>产生影响</li><li>说话并非总是可被用户接受的(如在公共办公室中和会议期 间)</li><li>纠错很<strong>费时</strong></li><li>与打字或指向相比，增加了<strong>认知负担</strong></li><li>没有独特的定制功能，编程困难</li></ul><h4 id="障碍">障碍</h4><ul><li>与视觉显示相比，语音输出的<strong>速度较慢</strong></li><li>语音具有<strong>短暂性</strong></li><li><strong>隐私问题</strong>：对VUI的潜在隐私侵犯涉及到一些用户。</li><li><strong>误解和缺乏准确性</strong>：语音识别软件仍然存在缺陷。软件无法理解和解释 语言的环境，从而导致错误和误解。用于自动打字的语音听写可能会导 致打字错误，因为 VUI 可能并不总是区分同音异义词。</li><li><strong>公共空间</strong>：由于隐私和噪音问题，很难向公共空间中的设备和 AI 助手发出语音命令。</li></ul><h3 id="语音生成的方法">语音生成的方法</h3><ul><li>语音合成（TTS，Text To Speech），就是将文字转换为声音输出的过程。</li><li>语音生成有三种常用方法:<ol type="1"><li><strong>峰段合成</strong>-通过一组基于文本语音表示的<strong>算法生成语音</strong></li><li><strong>串联合成</strong>-将事先录好的<strong>较短人类语音片段(音节)拼接</strong>为完整的 句子。</li><li><strong>语音录音</strong>-可将各个<strong>语音片段(词语、短句)拼合</strong>在一起，形成更长的语 音片段</li></ol></li></ul><h2 id="第十章">第十章</h2><h3 id="菲兹定律概念如何使用">菲兹定律（概念+如何使用）</h3><p><strong>菲茨定律</strong>是用来预测<strong>从任意一点到目标中心位置所需时间</strong>的数学模型。它由保罗.菲茨在1954年首先提出。这个模型考虑了<strong>用户定位点的初始位置</strong>与<strong>目标的相对距离(D)</strong>以及<strong>目标的大小(W)</strong>。用于估算用户移动光标点击链接或控件按钮所需的时间。</p><figure><img src="/img/post/20230606/5.png" alt="" /><figcaption>菲茨定律</figcaption></figure><p>其中：</p><ul><li><span class="math inline">\(\color{red}T\)</span>：光标完成移动的平均时间</li><li><span class="math inline">\(\color{red}a\)</span>：光标开始/停止移动的时间</li><li><span class="math inline">\(\color{red}b\)</span>：光标移动的速度</li><li><span class="math inline">\(\color{red}D\)</span>：目标的相对距离</li><li><span class="math inline">\(\color{red}W\)</span>：目标的大小</li></ul><p>意味着：</p><ul><li>在页面中，<strong>大而近</strong>的目标意味着用户无需做过多精细的调整就能到达目标。</li><li>反之，<strong>小而远的</strong>目标则意味着要将鼠标移动较长一段距离，并可能要做一些列精细调整，会<strong>很耗时</strong>。</li><li>距离<strong>越近</strong>，初始动作因为幅度太大而超出目标区域的<strong>风险越小</strong>。</li></ul><p>启示：</p><ol type="1"><li>按钮加大，点击更容易。</li><li>让<strong>相关的内容靠得更近</strong>，增强用户在视觉上对其相关性的认知，并减少光标移动的距离和时间。</li><li>屏幕的边角很适合防止菜单栏和按钮，因为<strong>边角是巨大的目标</strong>，鼠标不会超过它们。</li></ol><h2 id="第十一章">第十一章</h2><h3 id="协作模型7个维度-概念-例子">协作模型7个维度 概念 例子</h3><h4 id="moca协同行为模型">MoCA协同行为模型</h4><p>MoCA是在中间层和宏观层面运行的现代框架。整合了传统模型，并将传统模型扩展为包含7个维度的一个集合。</p><div class="note note-info">            <p>协同:指“相互依赖的两名或多名参与者在各自的活动中，针对某个特定目标通过行为域叠加所做出的努力。</p>          </div><figure><img src="/img/post/20230606/6.png" alt="" /><figcaption>协作模型</figcaption></figure><ul><li><strong>同步性</strong>：例如腾讯会议里面对面<strong>实时</strong>交流，同步性很大程度影响一次成功的协作的质量，假设网络连接中断，那么会议交流就会失去实时性，导致协作沟通存在延迟，影响协作质量。</li><li><strong>物理分布</strong>：团队协作可以在多种场合实现，从共用一张办公桌到同一个房间、建筑、校园、城市、国家、大陆或星球。因此协作是物理分布的或者是有空间分布的。 <div class="note note-info">            <p>例子：用户之间处于不同物理分布时，用户的协作方式会存在相应的变化，比如当用户物理位置在同一分布时（同一个房间，使用同一种语言），其协作沟通会更直接；而当其物理分布存在差异时（不同国家地区，使用不同语言），其协作会存在延迟，使用的交流工具也会变化（使用远程协作工具，翻译工具等）</p>          </div></li><li><strong>规模</strong>：规模指参与人数或协作规模，是影响交互性质和类型的一个重要维度。例如，与一人协作撰写论文并在维基百科上发表，与 10 人或 100 人协作相比差别巨大。在传统的组织中，处理规模较大任务的典型做法是：引入分解任务的层次结构，并明确权责。 <div class="note note-info">            <p>例子：公司企业存在协作规模，50 人的公司（小作坊）与上万人的企业协作相比差别巨大，小型公司部门较少，人员沟通交流更加密集直接，而大型企业部门数量多、跨度大，协作管理会更加困难，但是相应的协作交流的资源方式更加多样。</p>          </div></li><li><strong>践社区数</strong>：实践社区指的是，随着时间的推移，若干人互为老师和学生，形成一致的价值观、规范和实践，进而形成一个小组。 <div class="note note-info">            <p>例子：公司部门下，会有不同的项目小组，小组里有项目负责人与项目成员，成员也有各自不同的身份角色，随着工作时长的增加与项目的推进，项目小组会逐步形成完善对项目的理解与统一规范。实践社区数影响协作沟通的跨度与时空分布</p>          </div></li><li><strong>起源</strong>：新团体不断涌现，并协调彼此之间的行为。 起源的含义是，协同行为已发展到何种程序，或协同行为还未建立而正在发展之中。 <div class="note note-info">            <p>例子：公司成立新部门，新成立的部门需要与旧部门进行工作对接，需要与其他部门建立联系。起源影响协作的开始与发展计划。</p>          </div></li><li><strong>持久性</strong>：有些协同行为是短期的，有些则是长期的。例如，应对危机事件可能要花几小时、几天、几个月甚至几年的时间。不论合作是临时型的还是永久的，参与者都需要建立共享的词汇库，协调工作实践和输出。 <div class="note note-info">            <p>例子：项目计划存在计划持久性，项目不仅可以是同部门同项目小组成员之间的协作，也可以是跨部门跨项目协作，项目推进的时长影响协作的对象、时长、效率等等诸多方面，要求协作参与者之间需要建立共同的词汇库，协调工作实践和 输出。</p>          </div></li><li><strong>人员调整率</strong>：人员调整率是指合作中人的稳定性，即新参与者加入协作和离开协作有多频繁、协调行为一方面必须为彼此协作，人员流失率很低。 <div class="note note-info">            <p>例子：公司部门、部门项目小组招收新员工和老员工退出会影响协作的效率，新员工的加入需要时间适应学习，协作增加时间成本。老员工的退出需要建立工作对接，协作增加时间成本。低的人员调整率确保合作的高稳定性，协作沟通更有效率。</p>          </div></li></ul><h2 id="第十二章">第十二章</h2><h3 id="网页设计十大错误">网页设计十大错误</h3><ol type="1"><li>信息在网站中<strong>藏得太深</strong>。</li><li>页面<strong>加载了过多</strong>的内容。</li><li>提供的<strong>导航笨拙</strong>或令人困惑。</li><li>信息放到了页面之外。</li><li>链接不明显、不清楚。</li><li>显示信息的<strong>表格设计拙劣</strong>。</li><li><strong>文本太小</strong>，导致很多用户无法阅读。</li><li>文本使用了用户<strong>无法阅读的颜色组合</strong>。</li><li>使用了很差的表单。</li><li>隐藏（或不提供）能帮助用户的功能。</li></ol><h3 id="非拟人化设计">非拟人化设计</h3><p>将计算机<strong>呈现为人</strong>时，无论是合成人物还是卡通任务，均需谨慎。</p><ul><li>设计可理解、可预测和可控制的界面。</li><li>利用适当的人来做音频或视频介绍或向导。</li><li>在游戏或儿童软件中使用卡通人物，但在其他地方应避免使用它们</li><li>提供以用户为中心的概要，用于概述性和总结性内容。</li><li>计算机响应人的动作时，不使用第一人称代词“我” 。</li><li>使用“你”来指导用户或仅陈述事实</li></ul><h2 id="第十三章">第十三章</h2><h3 id="srt系统响应时间的概念影响因素">SRT（系统响应时间）的概念、影响因素</h3><ul><li><p><strong>SRT的概念</strong>： 从用户<strong>发起动作</strong>（通常为触碰图标、按回车键或点击鼠标）到<strong>计算机开始呈现反馈结果</strong>所需要的秒数。</p></li><li><p><strong>用户思考时间</strong>： 是从计算机响应到用户发起下一动作所花的秒数</p></li><li><p><strong>网站SRT</strong>: 要了解交互对用户性能、态度、压力和行为意图的影响，就需要评估延时和网站广度和内容熟悉度，进而研究网站的显示性能。 因素包括：</p></li><li><p>用户搜索目标信息</p></li><li><p>网络</p></li><li><p>微小变化会对关键指标造成很大的影响</p></li><li><p>消费需求是提升性能的关键因素</p></li><li><p>预先存储用户账号信息（如送货地址）</p></li></ul><p>影响<strong>用户对“SRT”的期望与态度</strong>的三个主要因素：以往的经验、个性的差异、任务的不同</p><h2 id="第十六章">第十六章</h2><h3 id="数据可视化的概念">数据可视化的概念</h3><p><strong>数据驱动图片</strong>的想法，称为可视化。（也叫“视觉数据挖掘”）</p><ul><li>可视化提供了紧凑的图形表示和用户界面，用于交互操作大量的项，这些项通常是从大型数据集中提取的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>人机交互</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Django+微信小程序】前后端分离跨站点POST请求踩坑实录</title>
    <link href="/2023/05/15/django-20230515/"/>
    <url>/2023/05/15/django-20230515/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>django版本3.2 在做前后端分离项目过程中需要用到跨站点POST请求，但会被django拦截。尽管将<code>settings.py</code>中的<code>django.middleware.csrf.CsrfViewMiddleware</code>注释掉可以解决，但在正式部署的情况下是不能这么做的，因为这会导致全局的csrf防护失效从而出现漏洞。</p><h2 id="解决方案">解决方案</h2><p>在settings.py中添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">CSRF_TRUSTED_ORIGINS = [<span class="hljs-string">&#x27;servicewechat.com&#x27;</span>] <br><span class="hljs-comment">#这是微信小程序的官方服务器域名，所有请求都从这里发出</span><br></code></pre></td></tr></table></figure><p>首先要使前后端能交流csrftoken和cookie:</p><p><strong>Django后端：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># xxx/views.py</span><br><span class="hljs-keyword">from</span> django.middleware.csrf <span class="hljs-keyword">import</span> get_token<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">token</span>(<span class="hljs-params">request</span>):<br>    token=get_token(request)<br>    <span class="hljs-keyword">return</span> JsonResponse(&#123;<span class="hljs-string">&#x27;token&#x27;</span>:token&#125;)<br><br><span class="hljs-comment"># xxx/urls.py</span><br><span class="hljs-comment"># 添加：</span><br>path(<span class="hljs-string">&#x27;token&#x27;</span>, views.token)<br></code></pre></td></tr></table></figure><p><strong>微信js前端：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getToken</span>(<span class="hljs-params">callback</span>) &#123;<br>  wx.<span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-title class_">DBPath</span> + <span class="hljs-string">&#x27;token&#x27;</span>,<br>    <span class="hljs-attr">success</span>:<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">if</span>(callback)<br>        <span class="hljs-title function_">callback</span>(res);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在小程序启动或者登录的时候向后端发送获取<code>csrftoken</code>的请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getToken</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    <span class="hljs-keyword">let</span> temp = (res.<span class="hljs-property">cookies</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;;&#x27;</span>)[<span class="hljs-number">0</span>]).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//split(&#x27;;&#x27;)[0]是因为csfttoken总是被django放在最前面</span><br>    wx.<span class="hljs-title function_">setStorageSync</span>(<span class="hljs-string">&#x27;csrftoken&#x27;</span>, res.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>);<br>    wx.<span class="hljs-title function_">setStorageSync</span>(<span class="hljs-string">&#x27;cookie&#x27;</span>, res.<span class="hljs-property">header</span>[<span class="hljs-string">&#x27;Set-Cookie&#x27;</span>]);<br>&#125;)<br></code></pre></td></tr></table></figure><p>在js的POST请求中添加请求头(以<code>wx.uploadFile</code>为例):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">wx.<span class="hljs-title function_">uploadFile</span>(&#123;<br>    <span class="hljs-attr">filePath</span>: path,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;file&#x27;</span>,<br>    <span class="hljs-attr">header</span>: &#123; <span class="hljs-comment">//必须包含cookie和X-CSRFToken</span><br>        <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>,<br>        <span class="hljs-comment">//上网找的解决方案都缺少这个cookie，我这边必须加上这个</span><br>        <span class="hljs-comment">//否则csrf cookie not set</span><br>        <span class="hljs-string">&#x27;cookie&#x27;</span>: wx.<span class="hljs-title function_">getStorageSync</span>(<span class="hljs-string">&#x27;cookie&#x27;</span>),<br>        <span class="hljs-string">&#x27;X-CSRFToken&#x27;</span>:  wx.<span class="hljs-title function_">getStorageSync</span>(<span class="hljs-string">&#x27;csrftoken&#x27;</span>) <br>    &#125;,<br>    <span class="hljs-attr">formData</span>:&#123;<br>        ...<br>    &#125;,<br>    <br>    <span class="hljs-attr">url</span>: <span class="hljs-title class_">DBPath</span> + <span class="hljs-string">&#x27;upload-avatar&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>微信小程序</tag>
      
      <tag>CSRF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Django】宝塔+Django3+uwsgi+nginx+MySQL部署踩坑实录</title>
    <link href="/2023/04/22/django-20230422/"/>
    <url>/2023/04/22/django-20230422/</url>
    
    <content type="html"><![CDATA[<p>待补充</p><h2 id="一服务器与宝塔面板">一、服务器与宝塔面板</h2><h3 id="镜像挑选">1. 镜像挑选</h3><p>这里我在腾讯云选购了亚太地区的服务器，选宝塔的应用模板。 选用宝塔是想降低部署难度。</p><figure><img src="/img/post/20230422/01.png" alt="" /><figcaption>宝塔实例</figcaption></figure><h3 id="更改root密码">2. 更改root密码</h3><p>在<code>更多 -&gt; 重置密码</code>里面重置root的密码</p><h3 id="配置宝塔面板">3. 配置宝塔面板</h3><p>实例启动之后，放行宝塔的端口</p><figure><img src="/img/post/20230422/02.png" alt="" /><figcaption>放行宝塔端口</figcaption></figure><p>查看宝塔的账号密码：</p><blockquote><p>/etc/init.d/bt default</p></blockquote><p>会看到: &gt;宝塔面板 &gt; &gt;外网面板地址: http://<strong>.</strong>.<em><strong>.</strong>:8888/</em>******* &gt;内网面板地址: http://<strong>.<em>.</em>.</strong>:8888/******** &gt; &gt;宝塔后台的用户名密码 &gt;username: ******* &gt;password: ********</p><p>根据上面的信息,进入宝塔面板,输入账号密码,然后有三件要做的事:</p><ol type="1"><li><p>注册并绑定宝塔账号</p></li><li><p>你安装LAMP, 选左边带nginx的安装</p></li><li><p>配置好你实例的镜像,按他的提示来就可以了</p></li></ol><h2 id="二mysql配置">二、MySQL配置</h2><p>自带MySQL的版本是<code>5.7</code></p><h3 id="创建数据库">1. 创建数据库</h3><h3 id="放行3306端口">2. 放行3306端口</h3><p><strong>宝塔面板</strong>和<strong>腾讯云</strong>的都要放行</p><h3 id="更改访问权限">3. 更改访问权限</h3><p>更改成所有人可访问</p><h3 id="测试连接">4. 测试连接</h3><p>我这里分别使用自带的phpMyAdmin和本地的SQLyog进行测试</p><h2 id="三django配置">三、Django配置</h2><h3 id="创建virtualenv虚拟环境">1. 创建virtualenv虚拟环境</h3><p>该实例自带两个python版本<code>python2(.7)</code>和<code>python3(.6)</code></p><p>为了避免权限问题, 我选择直接在<code>/www</code>下创建: &gt; cd /www/wwwroot/django</p><h3 id="配置需要用到的库">2. 配置需要用到的库</h3><blockquote><p>pip install django pymysql mysqlclien</p></blockquote><h3 id="创建一个测试项目">3. 创建一个测试项目</h3><h2 id="四uwsgi配置">四、uwsgi配置</h2><h3 id="配置uwsgi.ini">1. 配置uwsgi.ini</h3><p>在<code>manage.py</code>同级目录中创建<code>uwsgi.ini</code>,内容如下:</p><h3 id="安装uwsgi">2. 安装uwsgi</h3><blockquote><p>yum python-devel pip install uwsgi</p></blockquote><h3 id="测试uwsgi">3. 测试uwsgi</h3><h2 id="五nginx反向代理">五、nginx反向代理</h2><h2 id="六ssh连接测试">六、ssh连接测试</h2>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>uwsgi</tag>
      
      <tag>nginx</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Kotlin】学习笔记（六）扩展函数、运算符重载</title>
    <link href="/2023/04/17/kotlin/kotlin-20230417/"/>
    <url>/2023/04/17/kotlin/kotlin-20230417/</url>
    
    <content type="html"><![CDATA[<h2 id="一扩展函数">一、扩展函数</h2><ul><li><p>扩展函数可以在<strong>不修改类的定义的情况下，为类增加新的功能</strong>，可以为自定义类扩展，也可以扩展内置的类如<code>String、List</code></p></li><li><p>扩展函数的语法结构</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> ClassName.<span class="hljs-title">methodName</span><span class="hljs-params">(param1: <span class="hljs-type">Int</span>, param2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果要给String类增加一个<code>letterCount</code>方法对字符串中字母的数量进行统计：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">lettersCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> (char <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (char.isLetter()) &#123;<br>            count++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure><p>便可以进行使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">println(<span class="hljs-string">&quot;Adjkr#ip==1&quot;</span>.lettersCount()) <br><span class="hljs-comment">// &gt;&gt; 7</span><br></code></pre></td></tr></table></figure><h2 id="二运算符重载">二、运算符重载</h2><ul><li>使用运算符重载可以<strong>重新定义已有的运算符，赋予其另一种功能</strong>，以适应不同的数据类型。</li></ul><h3 id="使用operator进行重载">使用operator进行重载</h3><ul><li>以为<code>Vector</code>类重载加号运算符为例：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>(<span class="hljs-keyword">var</span> x: <span class="hljs-built_in">Float</span>, <span class="hljs-keyword">var</span> y: <span class="hljs-built_in">Float</span>) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(b: <span class="hljs-type">Vector</span>)</span></span>: Vector &#123;<br>        <span class="hljs-keyword">return</span> Vector(<span class="hljs-keyword">this</span>.x+b.x, <span class="hljs-keyword">this</span>.y+b.y)<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(<span class="hljs-subst">$&#123;this.x&#125;</span>, <span class="hljs-subst">$&#123;this.y&#125;</span>)&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = Vector(<span class="hljs-number">1f</span>, <span class="hljs-number">2f</span>)<br>    <span class="hljs-keyword">val</span> b = Vector(<span class="hljs-number">2f</span>, <span class="hljs-number">3f</span>)<br>    <span class="hljs-keyword">val</span> c = a + b<br>    println(c)<br>    <span class="hljs-comment">// &gt;&gt; (3.0, 5.0)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运算符方法名对照表">运算符方法名对照表</h3><figure><img src="../img/post/20230417/operator_name.png" alt="" /><figcaption>对照表</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Kotlin</tag>
      
      <tag>扩展函数</tag>
      
      <tag>运算符重载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据库】课堂笔记（二）关系模型与关系代数</title>
    <link href="/2023/03/04/database-20230304/"/>
    <url>/2023/03/04/database-20230304/</url>
    
    <content type="html"><![CDATA[<h2 id="一关系模型">一、关系模型</h2><ul><li>关系数据库系统：<strong>RDBMS</strong>，支持关系数据模型的数据库系统，当今的主流数据库管理系统。</li><li>关系模型的构成：由<strong>关系数据结构</strong>、<strong>关系操作集合</strong>和<strong>关系完整性约束</strong>三部分组成。</li></ul><h3 id="关系数据结构">1. 关系数据结构</h3><h4 id="关系">1. 关系</h4><ul><li>关系模型的数据结构简单，即二维表，亦称为关系</li><li>关系数据库：表的集合，即关系的集合。</li><li>表：一个实体集，一行就是一个实体，它由共同表示一个实体的相关联的若干属性的值所构成。</li></ul><h4 id="关系模式">2. 关系模式</h4><p>关系模式：描述关系，形式化表示：<code>r(U, D, DOM, F)</code> 。</p><ul><li>r：关系名；</li><li>U：组成关系的属性名的集合；</li><li>D：属性集U中所有属性所来自的域的集合；</li><li>DOM：属性向域的映像集合；</li><li>F：属性间数据依赖关系集合(元组各属性取值之间的关联性)。</li></ul><h4 id="关系与关系模式联系区别">3. 关系与关系模式联系区别</h4><ul><li>对于一个二维表，有表头部分和表体部分。<ul><li><code>表头部分</code>：定义表的结构，即定义表由哪些列构成(假设由n列构成)，每个列的名字和取值范围等；</li><li><code>表体部分</code>：所有数据行(元组)的集合，每个数据行都是由表头部分规定的n列有关联的取值的集合构成。</li></ul></li><li><strong>关系：</strong> 对应<code>表体部分</code>，每个数据行对应关系的一个元组，即关系是元组的集合。关系是 <strong>值</strong> 的概念。</li><li><strong>关系模式：</strong> 对应<code>表头部分</code>，定义元组集合的结构，即定义一个元组由哪些属性构成，每个属性的名字和取值域等。 关系模式是 <strong>型</strong> 的概念。</li></ul><h4 id="码">4. 码</h4><p><strong>超码：</strong> 关系r中的一个或多个属性的集合A，若A可以<code>唯一地标识</code>关系r中的一个元组，则称属性集A为关系r的一个超码 (superkey) 。</p><p><strong>候选码：</strong> 关系r的一个或多个属性的集合A，若A是关系r的超码，且A的任意真子集都不能成为关系r的超码，则称属性集A为候选码 (candidate key) 。</p><p><strong>主码：</strong> <u>若一个关系有多个候选码</u>，则可以选定其中的一个候选码作为该关系的主码 。</p><p><strong>外码：</strong> 设F是关系r的一个属性(或属性集)，Ks是关系s的主码。如果F与Ks相对应(即关系r中属性F的取值范围对应于关系s中主码Ks的取值范围的子集)，则称F是关系r参照关系s的外码(foreign key)，简称F是关系r的外码。</p><h3 id="关系完整性约束">2. 关系完整性约束</h3><h4 id="实体完整性">1. 实体完整性</h4><div class="note note-secondary">            <p>若属性集A是关系r的主码，则A<code>不能取空值null</code>。</p>          </div><h4 id="参照完整性">2. 参照完整性</h4><div class="note note-secondary">            <p>若属性(或属性集)F是关系r的外码，它与关系s的主码Ks相对应，则对于关系r中的每一个元组在属性F上的取值==要么为空值null，要么等于关系s中某个元组的主码值。</p>          </div><h4 id="用户自定义完整性">3. 用户自定义完整性</h4><div class="note note-secondary">            <p>针对<code>某一具体应用要求来定义的约束条件</code>，它反映某一具体应用所涉及的数据必须满足的语义要求。例如，</p><ul><li>限制关系中某些属性的取值符合业务语义要求。</li><li>限制关系中某些属性的取值之间满足一定的逻辑关系。</li><li>限制关系中某属性集上的取值必须唯一。</li></ul>          </div><h3 id="关系操作集合">3. 关系操作集合</h3><ul><li>关系操作的特点是<strong>集合操作方式</strong>，即操作的对象和结果都是集合。</li><li>操作方式也称为<strong>一次一个集合</strong>。</li><li>关系模型中的关系操作有<strong>查询操作</strong>和<strong>更新操作(插入、删除和修改)</strong>两大类 。<ul><li><strong>查询操作</strong>是关系操作中最主要的部分。查询操作又可以分为<code>选择</code>(select)、<code>投影</code>(project)、连接(join)、<code>除</code>(divide)、<code>并</code>(union)、<code>交</code>(intersection)、<code>差</code>(except)、<code>笛卡尔积</code>等。</li></ul></li><li>关系操作可用两种方式来表示 ——代数方式和逻辑方式。<ul><li><p><strong>关系代数：</strong> 用<code>代数方式</code>表达的关系查询语言。</p></li><li><p><strong>关系演算：</strong> 用<code>逻辑方式</code>表达的关系查询语言。关系演算又可按谓词变元的基本对象是元组变量还是域变量分为元组关系演算和域关系演算。</p></li><li><p>对于关系代数、元组关系演算和域关系演算均是抽象的查询语言，在表达能力上是完全等价的。</p></li></ul></li></ul><h2 id="二-关系代数">二、 关系代数</h2><p>关系代数通过关系代数运算构成的表达式来表达查询。 五种基本关系代数运算是：<code>∪，-，×，π和σ</code></p><h3 id="传统的集合运算">1. 传统的集合运算</h3><h4 id="并">1. 并</h4><ul><li><p>关系r与关系s的并记作 $${\color{Green} r} {\color{Red} \cup}  {\color{Green} s}  =\left \{{\color{Green} t} \mid{\color{Green} t} \in {\color{Green} r}\vee{\color{Green} t} \in {\color{Green} s}  \right \}$$</p></li><li><p>结果关系：n目关系，由属于r或属于s的所有元组组成。</p></li></ul><h4 id="差">2. 差</h4><ul><li><p>关系r与关系s的差记作 ： $${\color{Green} r} {\color{Red} -}  {\color{Green} s}  =\left \{{\color{Green} t} \mid{\color{Green} t} \in {\color{Green} r}\wedge{\color{Green} t} \notin {\color{Green} s}  \right \}$$</p></li><li><p>结果关系：n目关系，由属于r而不属于s的所有元组组成。</p></li></ul><h4 id="交">3. 交</h4><ul><li><p>关系r与关系s的交记作： $${\color{Green} r} {\color{Red} \cap}  {\color{Green} s}  =\left \{{\color{Green} t} \mid{\color{Green} t} \in {\color{Green} r}\wedge{\color{Green} t} \in {\color{Green} s}  \right \}$$</p></li><li><p>结果关系：n目关系，由既属于r又属于s的所有元组组成。等价表示：关系交可以通过差来表达，即 $${\color{Green} r} {\color{Red} \cap}  {\color{Green} s}  ={\color{Green} r} -\left({\color{Green} r} - {\color{Green} s}\right)$$</p></li></ul><h4 id="笛卡尔积">4. 笛卡尔积</h4><ul><li>两个分别为n目和m目的关系r和s的笛卡尔积是一个n+m目元组的集合。</li><li>元组的前n列是关系r的一个元组，后m列是关系s的一个元组。</li><li>若关系r有kr个元组，关系s有ks个元组，则关系r和s的笛卡尔积有kr×ks个元组。<code>笛卡尔积基数：kr*ks</code> $${\color{Green} r} {\color{Red} \times}  {\color{Green} s}  =\left \{{\color{Green} t_{r} } \cdot {\color{Green} t_{s}}\mid{\color{Green} t_{r}} \in {\color{Green} r}\wedge{\color{Green} t_{s}} \in {\color{Green} s}\right \}$$</li></ul><h3 id="专门的关系运算">2. 专门的关系运算</h3><h4 id="选择">1. 选择</h4><p>选择操作是在关系r中查找满足给定谓词（即选择条件）的所有元组，记作： $${\color{Red} \sigma_{{\color{Yellow} P} }} \left ( {\color{Green} r} \right ) =\left \{{\color{Green} t}  \mid {\color{Green} t}  \in\wedge{\color{Yellow} P} \left ({\color{Green} t} \right )\right \}$$ P：表示谓词(即选择条件)，它是一个逻辑表达式，取值为“真”或“假”。 说明：对关系从水平(行)角度进行运算，即选择操作。</p><h4 id="投影">2. 投影</h4><p>投影操作就是从关系r中选择若干属性列组成新的关系。 $${\color{Red} \Pi _{{\color{Yellow} A} }} ({\color{Green} r} ) = \{{\color{Green} t}[{\color{Green} A} ]  \mid {\color{Green} t}  \in {\color{Green} r} \}$$ A：为关系r的属性集合。 说明：对关系从纵向(列)的角度进行，即投影操作。</p><h4 id="连接">3. 连接</h4><p>连接也称θ连接。记为A op B，A、B分别为关系r和s中的属性个数相等且可比的连接属性集，op为比较运算符。 θ连接是从两个关系的笛卡尔积中选取连接属性间满足谓词θ的所有元组。 $${\color{Green} r} \, {\color{Red} \bowtie  _{{\color{Yellow} \theta } }} \, {\color{Green} s}  = \{{\color{Green} t_{r}} \cdot  {\color{Green} t_{s}} \mid {\color{Green} t_{s}}  \in {\color{Green} s} \wedge({\color{Green} r.A}  \, {\color{Yellow} op} \, {\color{Green} s.B} )\}$$</p><h4 id="象集非重点">4. 象集(非重点)</h4><p>给定关系r(A, B)，A和B是属性集。对任意t∈r，记t[A]=x，则在关系r中的属性集A的某个取值x的象集Bx定义： $${\color{Green} B} _{{\color{Yellow} x} } = \{ {\color{Green} t} {\color{Green} [B} ] \mid {\color{Green} t}  \in {\color{Green} r}  \wedge {\color{Green} t} [{\color{Green} A} ] = {\color{Yellow} x}  \}$$ 象集Bx的含义：表示关系r中属性集A上取值为x的所有元组在属性集B上的投影。</p><h4 id="除运算非重点">5. 除运算(非重点)</h4><p>设关系r®和s(S)，属性集S是R的子集，即S∈R，则关系r÷s是关系r中满足下列条件的元组在属性集R-S上的投影： trr，记 x= tr[R-S]，则关系r中属性集R-S的取值x的象集Sx包含关系s。记作 ： $${\color{Green} r} \, {\color{Red} {\div}}  \, {\color{Green} s} =\{ {\color{Green} t_{r}} [{\color{Purple} R-S} ] \mid {\color{Green} t_{r}}  \in {\color{Green} r}  \wedge{\color{Green} s}  \subseteq {\color{Green} S_{x}} \}$$</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Kotlin】学习笔记（五）泛型</title>
    <link href="/2023/03/01/kotlin/kotlin-20230301/"/>
    <url>/2023/03/01/kotlin/kotlin-20230301/</url>
    
    <content type="html"><![CDATA[<h2 id="一泛型方法">一、泛型方法</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">fromJson</span><span class="hljs-params">(json: <span class="hljs-type">String</span>, tClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T? &#123; <span class="hljs-comment">/*可空返回值*/</span><br>    <span class="hljs-keyword">val</span> instance: T? = tClass.newInstance()<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fromJson&lt;String&gt;(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, String::<span class="hljs-keyword">class</span>.java)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二泛型接口类">二、泛型接口/类</h2><h3 id="定义">1.定义</h3><p>定义<strong>泛型接口</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Drinks</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">taste</span><span class="hljs-params">()</span></span>: T<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">price</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>定义<strong>泛型类</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">var</span> t:T<span class="hljs-comment">/*泛型字段*/</span>) &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printColor</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用">2.使用</h3><p>继承泛型接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DrinkApple</span> : <span class="hljs-type">Drink</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">drink</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>        print(<span class="hljs-string">&quot;drink:<span class="hljs-subst">$&#123;s&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继承泛型类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlueColor</span>(<span class="hljs-keyword">val</span> color: String) : Color&lt;String&gt;(color) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printColor</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;printColor:<span class="hljs-subst">$&#123;color&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三泛型类型限定">三、泛型类型限定</h2><p>可以将泛型的<strong>范围限定为某个类及其子类</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//限定为JSONObject及其子类</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T: JSONObject&gt;</span> <span class="hljs-title">fromJson</span><span class="hljs-params">(json: <span class="hljs-type">String</span>, tClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T? &#123; <span class="hljs-comment">/*可空返回值*/</span><br>    <span class="hljs-keyword">val</span> instance: T? = tClass.newInstance()<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br><br><span class="hljs-comment">//传入的类型必须同时满足where子句的所有条件</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">fromJson</span><span class="hljs-params">(json: <span class="hljs-type">String</span>, tClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T? <span class="hljs-keyword">where</span> T : User, T: Comparable&lt;T&gt;&#123;<br>    <span class="hljs-keyword">val</span> instance: T? = tClass.newInstance()<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>in</code>, <code>out</code>关键字限定泛型类的上下限</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// Int 、 Long 都继承自Number</span><br>    <span class="hljs-keyword">val</span> l1 = ArrayList&lt;Number&gt;()<br>    l1.add(<span class="hljs-number">23</span>)    <br>    l1.add(<span class="hljs-number">1114</span>)<br>    <br>    <span class="hljs-keyword">val</span> l2 = ArrayList&lt;<span class="hljs-built_in">Long</span>&gt;()<br>    l2.add(<span class="hljs-number">1515461515545</span>)    <br>    l2.add(<span class="hljs-number">1114545124</span>)<br><br>    <span class="hljs-keyword">val</span> k1: ArrayList&lt;<span class="hljs-keyword">in</span> <span class="hljs-built_in">Int</span>&gt; = l1    <br>    <span class="hljs-keyword">val</span> k2: ArrayList&lt;<span class="hljs-keyword">out</span> Number&gt; = l2<br><br>    printArr(k1)<br>    printArr(k2)<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">printArr</span><span class="hljs-params">(arr : <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">for</span>(n <span class="hljs-keyword">in</span> arr) &#123;<br>        println(n)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Kotlin</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据库】课堂笔记（一）数据库系统概论</title>
    <link href="/2023/02/23/database-20230223/"/>
    <url>/2023/02/23/database-20230223/</url>
    
    <content type="html"><![CDATA[<h2 id="一数据与数据管理">一、数据与数据管理</h2><ol type="1"><li><p><strong>数据</strong></p><p>描述事物的符号记录称为<strong>数据</strong>。数据是数据库(DB)中存储的对象，也是数据库管理系统(DBMS)处理的对象。</p><p><strong>结构化数据</strong>：由数据库二维逻辑结构（表格）描述的数据。</p><p><strong>非结构化数据</strong>：不方便用数据库二维逻辑结构表现的数据，包括所有文档、文本、图片、音视频等。</p><p><strong>半结构化数据</strong>：介于完全结构化数据（关系型数据库，面向对象数据库中的数据）和完全无结构的数据（如自然语言文本、音视频、图像等）。如XML文档，数据的结构和内容混在一起。 <br/></p></li><li><p><strong>数据管理</strong></p><p><strong>数据处理</strong>：对各种数据进行采集、存储、加工、传播和应用等一系列活动的总和。从大量、可能杂乱无章、难以理解的数据中抽取并推导出对于某些特定的人们来说有价值、有意义的数据。</p><p><strong>数据管理</strong>：对数据进行有效的分类、组织、编码存储、检索、维护和应用，是数据处理的中心问题。 <br/></p></li></ol><h2 id="二数据管理技术发展的三个阶段">二、数据管理技术发展的三个阶段</h2><h3 id="人工管理阶段">1.人工管理阶段</h3><ul><li>数据不保存</li><li>数据不共享，数据冗余大</li><li>数据不具有独立性</li></ul><pre><code class=" mermaid">graph LR应用程序1---数据集1;应用程序2---数据集2;</code></pre><h3 id="文件系统阶段">2.文件系统阶段</h3><ul><li>数据以“文件”形式长期保存</li><li>按文件名访问，按记录进行存取</li><li>数据的逻辑结构与物理结构有了区别</li><li>数据面向应用</li></ul><pre><code class=" mermaid">graph LRa((存取方法))应用程序1 --- a;应用程序2 --- a;a --- 文件组1;a --- 文件组2;</code></pre><h3 id="数据库管理系统阶段">3.数据库管理系统阶段</h3><ul><li>使用数据库管理系统(DBMS)进行管理</li><li>数据面向整个应用系统</li><li>数据共享性高，冗余度小</li><li>数据具有高度的物理独立性和逻辑独立性</li><li>数据整体结构化，用数据模型描述</li><li>由数据库管理系统提供数据安全性、完整性、并发控制和恢复能力</li></ul><h2 id="三重要概念">三、重要概念</h2><h3 id="数据独立性">1. 数据独立性</h3><ul><li><p>数据独立：数据的使用（应用程序）与数据的说明（数据组织结构与存储方式）分离，使数据的组织和存储结构（在一定范围内）变更时不必修改应用程序。</p></li><li><p>物理独立性：用户的应用程序在一定程度上独立于数据库中数据的物理<strong>存储</strong>结构。（数据在<strong>物理存储结构</strong>上的改变不需要相应修改程序）</p></li><li><p>逻辑独立性：用户的应用程序在一定程度上独立于数据库中数据的全局逻辑（<strong>组织</strong>）结构。（<strong>数据库总体逻辑结构</strong>的改变不需要相应修改程序）</p></li></ul><h3 id="数据冗余">2. 数据冗余</h3><ul><li>相同数据在不同地方<strong>重复存储</strong>。</li></ul><h3 id="完整性">3. 完整性</h3><ul><li>指数据的正确性、有效性和相容性，也称为一致性约束。（如必须满足某个规定才能插入新数据）</li></ul><h3 id="整体结构化">4.整体结构化</h3><ul><li>数据库的<strong>主要特征</strong>之一，也是数据库管理系统与文件按系统的本质区别。</li><li>指数据不仅仅是内部结构化，而是将<strong>数据以及数据之间的联系统一管理</strong>起来，使之结构化。（如几张数据表之间存在一致性约束）</li><li>指在数据库中的数据不仅仅针对某一个应用，而是<strong>面向全（相关）组织的所有应用</strong>。（一份数据供多个相关应用使用）</li></ul><h3 id="数据库管理系统dbms">5. 数据库管理系统(DBMS)</h3><ul><li>由一个<strong>相互关联的数据的集合</strong>和一组<strong>用以访问、管理和控制这些数据的程序</strong>组成。</li><li>该数据集合称为<strong>数据库</strong>。</li><li>DBMS能提供一个方便且高效地存取、管理和控制数据库信息的环境。</li><li>DBMS的特点：<ul><li>数据（整体）<strong>结构化</strong></li><li>数据<strong>共享度高，冗余度低</strong>，易扩充</li><li>数据<strong>独立性高</strong></li></ul></li></ul><h2 id="四数据模型">四、数据模型</h2><h3 id="概念">1. 概念</h3><p>数据模型是一个<strong>描述数据结构、数据操作以及数据约束</strong>的数学形式体系。数据结构用于刻画数据、数据语义以及数据之间的联系；数据约束是对数据结构和数据操作的一致性、完整性约束。</p><h3 id="分层">2. 分层</h3><p>根据<strong>数据抽象的不同级别</strong>，将数据模型分为3层：</p><pre><code class=" mermaid">flowchart TB    a1((现实世界));    subgraph 数据模型        b1[概念模型];        c1[逻辑模型];        d1[物理模型];                b1--数据库设计工具协助设计人员--&gt;c1;        c1--DBMS--&gt;d1;    end    a1--数据库设计人员--&gt;b1;</code></pre><ol type="1"><li><strong>概念模型</strong><ul><li>按用户的观点或认识对现实世界的数据和信息进行建模，主要<strong>用于数据库设计</strong>。</li><li>特点：语义表达能力强；易于理解；独立于任何DBMS；容易转换成不同DBMS所支持的逻辑数据模型。</li><li>常用：<strong>E-R模型</strong>（实体-联系模型）、<strong>OO模型</strong>（面向对象模型） <br></li></ul></li><li><strong>逻辑模型</strong><ul><li>是用户通过DBMS看到的现实世界，是按计算机系统的观点对数据建模，即计算机的实现形式，主要<strong>用于DBMS的实现</strong>。</li><li>特点：既要考虑用户容易理解，又要考虑便于DBMS的实现。</li><li>常用：传统模型（层次模型、网状模型、关系模型）、面向对象模型（XML模型）。 <br></li></ul></li><li><strong>物理模型</strong><ul><li>数据抽象的最底层，用来<strong>描述数据的物理存储结构和存取方法</strong>。</li><li>特点：不仅由DBMS的设计决定，还于操作系统、计算机硬件密切相关。数据库设计人与要了解和选择物理模型，一般用户则不必考虑。</li></ul></li></ol><h3 id="组成要素">3. 组成要素</h3><ol type="1"><li><strong>数据结构</strong> 描述<strong>数据库的组成对象以及对象之间的关系</strong>。是对系统<strong>静态特性</strong>的描述。 <br></li><li><strong>数据操作</strong> 指对数据库中各种对象的实例（类的实例）<strong>允许执行的操作集合</strong>（增删改查），包括相关操作规则。是对系统<strong>动态特性</strong>的描述。 <br></li><li><strong>数据完整性约束</strong> 是<strong>一组数据完整性规则</strong>,用以限定符合数据模型的数据库状态以及状态的变化，以<strong>确保数据的正确、有效和相容</strong>。</li></ol><h3 id="层次模型">4. 层次模型</h3><p>层次模型用<strong>树形结构</strong>标识各类实体以及实体间的联系。</p><p><strong>特征：</strong></p><ol type="1"><li>有且仅有一个节点没有父节点，即根节点</li><li>根以外的其他节点有且仅有一个父节点</li></ol><figure><img src="/img/post/20230223/%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B.jpg" alt="" /><figcaption>层次模型</figcaption></figure><p><strong>优点：</strong></p><ol type="1"><li>结构简单、清晰、明朗</li><li>查询效率较高</li><li>提供了较好的数据完整性支持</li></ol><p><strong>缺点：</strong></p><ol type="1"><li>结构呆板，缺乏灵活性</li><li>层次数据模型只能表示实体之间的一对多的关系，<strong>不能表示多对多的复杂关系</strong>，因此现实世界中的很多模型不能通过该模型方便的表示</li><li>查询节点的时候必须知道其双亲节点的，限制了对数据库存取路径的控制</li></ol><h3 id="网状模型">5. 网状模型</h3><p>网关模型用<strong>有向图</strong>表示实体和实体之间的联系。</p><p><strong>特征：</strong></p><ol type="1"><li>可以存在两个或者多个节点没有父节点</li><li>允许单个节点存在多于一个父节点</li></ol><figure><img src="/img/post/20230223/%E7%BD%91%E7%8A%B6%E6%A8%A1%E5%9E%8B.jpg" alt="" /><figcaption>网状模型</figcaption></figure><p><strong>优点：</strong></p><ol type="1"><li>可以更直观地直接描述现实世界</li><li>具有良好的性能，存取效率较高</li></ol><p><strong>缺点：</strong></p><ol type="1"><li><strong>结构复杂</strong>，不利于最终用户掌握</li><li>操作语言比较复杂</li></ol><h3 id="关系模型">6. 关系模型</h3><p>使用<strong>表格</strong>表示实体和实体之间关系的数据模型</p><p><strong>特征：</strong></p><ol type="1"><li>关系数据模型中，无论是是实体、还是实体之间的联系都是被映射成统<strong>二维表</strong>关系，在关系模型中，操作的对象和结果都是一张二维表</li><li>关系型数据库可用于表示实体之间的多对多的关系，只是此时要<strong>借助第三个关系表</strong>，来实现多对多的关系</li><li>关系必须是规范化的关系，即每个属性是不可分割的实体，<strong>不允许表中表</strong>的存在</li></ol><figure><img src="/img/post/20230223/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B.jpg" alt="" /><figcaption>关系模型</figcaption></figure><p>可以看到学生与课程之间的联系以及教师和课程之间的多对多联系都被映射成了表格。其中选课表中的sut_id和cour_id分别是引用学生表和课程表的cour_id的外键；教课表也是如此。</p><p><strong>优点：</strong></p><ol type="1"><li>建立在严格的数学概念的基础上，有关系代数作为语言模型，有关系数据理论作为理论基础</li><li>概念单一，实体、实体的联系以及对数据操作的结果都是关系，故结构简单清晰，易用</li><li>存取路径相对透明，从而数据独立性更高，安全保密性更好，简化了程序员工作，提高了开发和维护效率</li></ol><p><strong>缺点：</strong></p><ol type="1"><li>存取路径相对透明，导致查询效率往往不如非关系数据模型</li></ol><h2 id="五数据抽象与数据库三级模式">五、数据抽象与数据库三级模式</h2><h3 id="数据抽象层次">1. 数据抽象层次</h3><ol type="1"><li><p><strong>视图层</strong>：描述数据库的某个部分，是数据库的局部逻辑结构（取出数据库中的部分数据）</p></li><li><p><strong>逻辑层</strong>：描述数据库中存储什么数据以及这些数据的关系</p></li><li><p><strong>物理层</strong>：描述数据的存储结构和存取方法</p></li></ol><h4 id="三级模式">2. 三级模式</h4><ol type="1"><li><p><strong>外模式</strong></p><ul><li>也称<strong>用户模式</strong>或<strong>子模式</strong>，对应于<strong>视图层</strong>数据抽象，是数据库用户（程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是<strong>数据库用户的数据视图</strong></li><li>用户只能看见和访问<strong>对应的外模式</strong>中的数据，<strong>其余数据则不可见</strong> <br></li></ul></li><li><p><strong>模式</strong></p><ul><li>也称为<strong>逻辑模式</strong>或<strong>概念模式</strong>，对应于<strong>逻辑层</strong>数据抽象，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图</li><li>与硬件、应用程序、开发工具和高级程序设计语言无关</li></ul></li><li><p><strong>内模式</strong></p><ul><li>也称<strong>存储模式</strong>，是数据的物理结构和存储方式的描述，是数据在数据库内部的表示方式</li></ul></li></ol><h3 id="两层映像">3. 两层映像</h3><p><strong>作用</strong>：保证DBMS中的数据能够具有较高的逻辑独立性和物理独立性。</p><ol type="1"><li><p><strong>外模式/模式映像</strong></p><ul><li>定义了该外模式与模式之间的对应关系</li><li>一个模式（全局）可以有多个外模式(局部)</li><li>保证数据与应用程序的<strong>逻辑独立性</strong></li></ul></li><li><p><strong>模式/内模式映像</strong></p><ul><li>定义了数据全局逻辑结构与存储结构之间的对应关系</li><li>数据库中仅有一个内模式和一个模式，故<strong>模式/内模式映像是唯一的</strong></li><li>保证数据与应用程序的<strong>物理独立性</strong></li></ul></li></ol><h3 id="数据抽象三层模型与三级模式与的关系">4. 数据抽象、三层模型与三级模式与的关系</h3><p>数据抽象是在不同的层次之间提供概念上的统一，使得不同层次的应用程序可以通过抽象层进行交互，而不必关心底层的实现细节。</p><p>三级模式描述了数据库系统的三个不同层次的逻辑结构，而三层模型是对三级模式的抽象和概括，分别对应了不同的层次：用户层、逻辑层和物理层。</p><p>三级模式更加关注于数据库的逻辑结构，而三层模型则更加关注于不同层次之间的关系和交互。三层模型的出现是为了方便不同层次之间的交互和协作，使得数据管理更加高效、灵活、易于扩展。</p><figure><img src="/img/post/20230223/%E8%81%94%E7%B3%BB.png" alt="" /><figcaption>联系</figcaption></figure><h2 id="六数据库系统与数据库管理系统">六、数据库系统与数据库管理系统</h2><h3 id="数据库系统">1. 数据库系统</h3><p><strong>数据库系统（DBS）</strong> 是指在计算机系统中引入数据库后的系统，一般由<strong>数据库</strong>、<strong>数据库管理系统</strong>、<strong>应用系统</strong>、<strong>数据库管理员</strong>和<strong>最终用户</strong>构成。</p><h3 id="数据库管理系统">2. 数据库管理系统</h3><p><strong>数据库管理系统（DBMS）</strong> 是一组负责数据库的访问、管理和控制的软件，用以完成用户对数据库的各种操作请求。</p><ol type="1"><li><p><strong>DBMS的功能</strong></p><ul><li>数据定义</li><li>数据组织、存储和管理</li><li>数据操纵</li><li>数据库的事物管理和运行管理</li><li>数据库的建立和维护等</li></ul></li><li><p><strong>DBMS的组成</strong></p><figure><img src="/img/post/20230223/DBMS%E7%BB%84%E6%88%90.png" alt="" /><figcaption>DBMS组成</figcaption></figure><p>其中：</p><ul><li><strong>模式更新</strong>：对数据库的逻辑结构进行修改，如在一张表中增加一列属性</li><li><strong>查询处理器</strong>：对用户请求的SQL操作进行查询优化，或更新数据库中相应的数据</li><li><strong>事务管理器</strong>：负责资源管理，事务调度，保证数据库的一致性，保证多个同时运行的事务不冲突，以及保证当系统故障时数据不丢失</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库，笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Kotlin】学习笔记（四）集合类</title>
    <link href="/2023/02/04/kotlin/kotlin-20230204/"/>
    <url>/2023/02/04/kotlin/kotlin-20230204/</url>
    
    <content type="html"><![CDATA[<h2 id="一list">一、List</h2><p>在Java中，我们可以使用ArraryList，当然在Kotlin中也可以这么做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list1 = ArraryList&lt;String&gt;()<br>list1.add(<span class="hljs-string">&quot;Apple&quot;</span>)<br>list1.add(<span class="hljs-string">&quot;Banana&quot;</span>)<br>list1.add(<span class="hljs-string">&quot;Pear&quot;</span>)<br></code></pre></td></tr></table></figure><p>Kotlin中提供了两种内置函数 <code>listOf()</code> 和 <code>mutableListOf()</code> 来简化初始化List的写法。</p><p>前者创建的List不可修改，而后者可修改：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list1 = listOf(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>)<br><span class="hljs-comment">//list1.add(&quot;Grape&quot;) //报错</span><br><br><span class="hljs-keyword">val</span> list2 = mutableListOf(<span class="hljs-string">&quot;Kim&quot;</span>, <span class="hljs-string">&quot;Sam&quot;</span>, <span class="hljs-string">&quot;Lisa&quot;</span>)<br>list2.add(<span class="hljs-string">&quot;Jack&quot;</span>) <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p>我们可以用<code>for-in</code>循环遍历这些集合</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> (fruit <span class="hljs-keyword">in</span> list1) &#123;<br>    println(fruit)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二set">二、Set</h2><p>Set集合与List集合的用法相近，只是Set集合不能存放重复元素。</p><p>Kotlin中同样提供了两种内置函数 <code>setOf()</code> 和 <code>mutableSetOf()</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> <span class="hljs-keyword">set</span> = mutableSetOf(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>)<br><span class="hljs-keyword">set</span>.add(<span class="hljs-string">&quot;Apple&quot;</span>) <span class="hljs-comment">//重复元素，不添加</span><br><span class="hljs-keyword">set</span>.add(<span class="hljs-string">&quot;Grape&quot;</span>) <span class="hljs-comment">//非重复，添加成功</span><br><span class="hljs-keyword">for</span> (fruit <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>) &#123;<br>    println(fruit)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三map">三、Map</h2><p>与其他语言一样，Map是一种以键值对形式的的数据结构，Java中的通常做法是创建一个HashMap实例，用<code>put()</code>和<code>get()</code>去操作这个Map：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> map1 = HashMap&lt;String, <span class="hljs-built_in">Int</span>&gt;()<br>map1.put(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-number">1</span>)<br>map1.put(<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-number">2</span>)<br>map1.put(<span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>在Kotlin中，我们也可以使用类似JavaScript的下标语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">map1[<span class="hljs-string">&quot;Grape&quot;</span>] = <span class="hljs-number">4</span><br><span class="hljs-keyword">val</span> num = map1[<span class="hljs-string">&quot;Apple&quot;</span>]<br></code></pre></td></tr></table></figure><p>当然，Kotlin中也提供了 <code>mapOf()</code> 和 <code>mutableMapOf()</code>来简化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> map1 = mapOf(<br>    <span class="hljs-string">&quot;Apple&quot;</span>     to <span class="hljs-number">1</span><br>    <span class="hljs-string">&quot;Banana&quot;</span>    to <span class="hljs-number">2</span><br>    <span class="hljs-string">&quot;Pear&quot;</span>      to <span class="hljs-number">3</span><br>)<br></code></pre></td></tr></table></figure><p>其中的 <strong>to</strong> 并不是关键字，而是一个 <strong>infix函数</strong>。</p><p>同样，可以使用for循环去遍历Map</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> ((fruit, number) <span class="hljs-keyword">in</span> map1) &#123;<br>    println(<span class="hljs-string">&quot;fruit is &quot;</span> + fruit + <span class="hljs-string">&quot;, number is &quot;</span> + number)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四集合常用lambda操作">四、集合常用lambda操作</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> li = listOf(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br><br><span class="hljs-keyword">val</span> a = li.maxBy&#123;it&#125;        <span class="hljs-comment">//最大值，同理有minBy</span><br>println(<span class="hljs-string">&quot;maxBy: %a&quot;</span>)        <span class="hljs-comment">// 5</span><br><br><span class="hljs-keyword">val</span> b = li.filter&#123;it &gt; <span class="hljs-number">3</span>&#125;   <span class="hljs-comment">// 过滤器</span><br>println(<span class="hljs-string">&quot;filter: &quot;</span>)<br><span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> b) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$n</span> &quot;</span>)            <span class="hljs-comment">// 5 4</span><br>&#125;<br>println()<br><br><span class="hljs-keyword">val</span> c = li.sortedBy&#123;it&#125;     <span class="hljs-comment">// 升序排序，加-号为降序</span><br>println(<span class="hljs-string">&quot;sortBy: &quot;</span>)<br><span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> c) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$n</span> &quot;</span>)            <span class="hljs-comment">// 1 2 3 4 5</span><br>&#125;<br>println()<br><br><span class="hljs-keyword">val</span> d = li.map&#123;it * <span class="hljs-number">2</span>&#125;      <span class="hljs-comment">//将集合内的值改为另一个值</span><br>println(<span class="hljs-string">&quot;map: &quot;</span>)<br><span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> d) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$n</span> &quot;</span>)            <span class="hljs-comment">// 2 6 10 4 8</span><br>&#125;<br>println()<br><br><span class="hljs-keyword">val</span> e = li.mapIndexed&#123;      <span class="hljs-comment">//同上，但lambda参数带下标</span><br>    index, value -&gt; index * value<br>&#125;      <br>println(<span class="hljs-string">&quot;map: &quot;</span>)<br><span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> e) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$n</span> &quot;</span>)            <span class="hljs-comment">// 0 3 10 6 16 </span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Kotlin</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Kotlin】学习笔记（三）Lambda表达式</title>
    <link href="/2023/02/03/kotlin/kotlin-20230203/"/>
    <url>/2023/02/03/kotlin/kotlin-20230203/</url>
    
    <content type="html"><![CDATA[<h2 id="lambda变量">1.Lambda变量</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sum = &#123;a: <span class="hljs-built_in">Int</span>, b: <span class="hljs-built_in">Int</span> -&gt; <br>    a + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(sum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lambda表达式作为参数匿名函数">2.Lambda表达式作为参数（匿名函数）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transform</span><span class="hljs-params">(arr: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Int</span>&gt;, action: (<span class="hljs-type">index</span>: <span class="hljs-type">Int</span>, <span class="hljs-type">ele</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-comment">//遍历下标集</span><br>    <span class="hljs-keyword">for</span> (index <span class="hljs-keyword">in</span> arr.indices) &#123;<br>        <span class="hljs-keyword">val</span> newValue = action(index, arr[index])<br>        arr[index] = newValue<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> numbers = arrayOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>    <span class="hljs-comment">//传入Lambda: 将数组的每个元素与其下标相乘</span><br>    <span class="hljs-comment">//效果与 numbers.mapIndexed&#123;index, value -&gt; index * value&#125; 相当</span><br>    transform(numbers, &#123;index, ele -&gt; <br>        index * ele<br>    &#125;)<br>    <br>    <span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> numbers) &#123;<br>        println(n)<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进阶语法">3.进阶语法</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fun1</span><span class="hljs-params">(action: (<span class="hljs-type">a</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>&#123;<br>    println(action(<span class="hljs-number">3</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 原表达式</span><br>    fun1(&#123;value:<span class="hljs-built_in">Int</span> -&gt; value * value&#125;)<br><br>    <span class="hljs-comment">// 1.由于可以自动推导类型，故省略类型声明</span><br>    fun1(&#123;value -&gt; value * value&#125;)<br><br>    <span class="hljs-comment">// 2.当lambda表达式是函数中最后一个参数时，可以将其放在函数后面</span><br>    fun1()&#123;value -&gt; value * value&#125;<br><br>    <span class="hljs-comment">// 3.当函数括号内没有参数时，可以省略括号</span><br>    fun1&#123;value -&gt; value * value&#125;<br><br>    <span class="hljs-comment">// 4.当lambda表达式参数只有一个时，可以省略，改用it指代</span><br>    fun1&#123;it * it&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Kotlin</tag>
      
      <tag>Lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Kotlin】学习笔记（二）面向对象编程</title>
    <link href="/2023/02/02/kotlin/kotlin-20230202/"/>
    <url>/2023/02/02/kotlin/kotlin-20230202/</url>
    
    <content type="html"><![CDATA[<h2 id="一类与对象">一、类与对象</h2><p>下面的将示范如何创建一个Kotlin类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;      <span class="hljs-comment">//类名：Person</span><br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span>   <span class="hljs-comment">//类成员变量</span><br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">//类成员函数</span><br>        println(name + <span class="hljs-string">&quot;，&quot;</span> + age + <span class="hljs-string">&quot;岁&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将这个类进行<strong>实例化</strong>，获得一个<strong>对象</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> p = Person() <span class="hljs-comment">//跟Java相比，去掉了new关键字</span><br>    p.name = <span class="hljs-string">&quot;田所浩二&quot;</span><br>    p.age = <span class="hljs-number">24</span><br>    p.show()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二类的继承与构造函数">二、类的继承与构造函数</h2><p>首先，在Kotlin中，所有非抽象类默认都是不可继承的，就像Java中的<code>final</code>声明的类，要使得类能悲继承，需要<code>open</code>关键字。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;      <span class="hljs-comment">//类名：Person</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们让<code>Student</code>类继承<code>Person</code>类，使用一个冒号，注意被继承类名后面的括号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-type">Person</span>() &#123;<br>    <span class="hljs-keyword">var</span> id = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> grade = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外是关于构造函数的部分。Kotlin将构造函数分成了两种：<strong>主构造函数</strong>和<strong>次构造函数</strong>。</p><h3 id="主构造函数">1.主构造函数</h3><p><strong>主构造函数</strong>是每个类默认都会有的一个不带参数的构造函数，我们也可以给它指定参数。主构造函数没有函数体，直接定义在类名后面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> id: String, <span class="hljs-keyword">val</span> grade: <span class="hljs-built_in">Int</span>): Person() &#123;<br>    <span class="hljs-comment">//在主构造函数中声明为val或var的参数会自动成为该类的成员</span><br>&#125;<br><br><span class="hljs-comment">//实例化的时候：传入构造函数的所有参数：</span><br><span class="hljs-keyword">val</span> student = Student(<span class="hljs-string">&quot;1145141919810&quot;</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>主构造函数没有函数体，如果想在其中编写逻辑，可以使用init结构体：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> id: String, <span class="hljs-keyword">val</span> grade: <span class="hljs-built_in">Int</span>): Person() &#123;<br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;id is &quot;</span> + id)<br>        println(<span class="hljs-string">&quot;grade is &quot;</span> + grade)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据继承的规定，<strong>子类的构造函数必须调用父类的构造函数</strong>，我们就需要在括号中填入父类构造函数的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//将Person类的主构造函数改为：</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//将Student类的继承改为：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> id: String, <span class="hljs-keyword">val</span> grade: <span class="hljs-built_in">Int</span>, name: String, age: <span class="hljs-built_in">Int</span>): <br>    Person(name, age) &#123; <span class="hljs-comment">//这里的name, age仅作为参数，不生成成员字段，防止父类同名成员的冲突</span><br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;id is &quot;</span> + id)<br>        println(<span class="hljs-string">&quot;grade is &quot;</span> + grade)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="次构造函数">2.次构造函数</h3><p>一个类能有多个次构造函数，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> id: String, <span class="hljs-keyword">val</span> grade: <span class="hljs-built_in">Int</span>, name: String, age: <span class="hljs-built_in">Int</span>): <br>    Person(name, age) <br>&#123; <br>    <br>    <span class="hljs-keyword">constructor</span>(name: String, age: <span class="hljs-built_in">Int</span>): <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, name, age) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">constructor</span>(): <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>) &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> st1 = Student()<br><span class="hljs-keyword">val</span> st2 = Student(<span class="hljs-string">&quot;我修院卓&quot;</span>, <span class="hljs-number">23</span>)<br><span class="hljs-keyword">val</span> st3 = Student(<span class="hljs-string">&quot;1145141919810&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;田所浩二&quot;</span>, <span class="hljs-number">24</span>)<br></code></pre></td></tr></table></figure><p>如果类中<strong>没有主构造函数，只有次构造函数</strong>该怎么继承？代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-type">Person</span> &#123; <span class="hljs-comment">//没有主构造，故不用写括号</span><br>    <span class="hljs-comment">//以super关键字直接调用父类构造函数</span><br>    <span class="hljs-keyword">constructor</span>(name: String, age: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">super</span>(name, age) &#123;&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三接口">三、接口</h2><p>不同于C++的多继承，Java和Kotlin都是单继承结构的语言，最多只允许继承一个父类，但可以实现任意个<strong>接口</strong> 接口中定义的函数可以不实现，也可以定义默认的实现。Kotlin只会强制要求实现没有默认实现的函数。 接口定义方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readBooks</span><span class="hljs-params">()</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doHomework</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;doing homework&quot;</span>) <span class="hljs-comment">//默认的实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>让<code>Student</code>类实现这个接口, 和继承的写法一样，然后再使用<code>override</code>关键字重载接口定义的函数:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(name: String, age: <span class="hljs-built_in">Int</span>) : Person(name, age), Study &#123; <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readBooks</span><span class="hljs-params">()</span></span> &#123;<br>        println(name + <span class="hljs-string">&quot; is reading.&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doHomework</span><span class="hljs-params">()</span></span> &#123;<br>        println(name + <span class="hljs-string">&quot; is doing homework&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//使用这个类:</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> stu = Student(<span class="hljs-string">&quot;田所浩二&quot;</span>, <span class="hljs-number">24</span>)<br>    doStudy(stu)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(stu: <span class="hljs-type">Study</span>)</span></span> &#123; <br>    <span class="hljs-comment">//只有继承了Study接口的类的对象才能使用该函数</span><br>    stu.readBooks()<br>    stu.doHomework()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四可见性修饰符">四、可见性修饰符</h2><p>Java中有四种修饰符：<code>public</code>、<code>private</code>、<code>protected</code>、<code>default</code>，默认是<code>default</code>。</p><p>Kotlin也有四种：<code>public</code>、<code>private</code>、<code>protected</code>、<code>internal</code>， 默认是<code>public</code>。</p><table><thead><tr class="header"><th>修饰符</th><th>Java</th><th>Kotlin</th></tr></thead><tbody><tr class="odd"><td>public</td><td>所有类可见</td><td>所有类可见(默认)</td></tr><tr class="even"><td>private</td><td>当前类可见</td><td>当前类可见</td></tr><tr class="odd"><td>protected</td><td>当前类、子类、同一煲路径下的类可见</td><td>当前类，子类可见</td></tr><tr class="even"><td>default</td><td>同一包路径下的类可见(默认)</td><td>无</td></tr><tr class="odd"><td>internal</td><td>无</td><td>同一模块中的类可见</td></tr></tbody></table><h2 id="五数据类">五、数据类</h2><p>在一个规范的系统架构中，<strong>数据类</strong>用于将服务器端或数据库中的数据映射到内存中，为编程逻辑提供数据模型的支持。</p><p>在Java中数据类通常需要重写<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>这几个方法，而Kotlin则只需要一个<code>data</code>关键字，这些方法便会自动生成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cellphone</span>(<span class="hljs-keyword">val</span> brand: String, <span class="hljs-keyword">val</span> price: <span class="hljs-built_in">Double</span>)<br></code></pre></td></tr></table></figure><p>当一个类内部没有任何代码，便可以将大括号省略。 下面测试一下这个数据类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> cellphone1 = Cellphone(<span class="hljs-string">&quot;Samsung&quot;</span>, <span class="hljs-number">1299.99</span>)<br>    <span class="hljs-keyword">val</span> cellphone2 = Cellphone(<span class="hljs-string">&quot;Samsung&quot;</span>, <span class="hljs-number">1299.99</span>)<br>    println(cellphone1)<br>    println(<span class="hljs-string">&quot;cellphone1 == cellphone2 ? &quot;</span> + (cellphone1 == cellphone2))<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><pre><code class="hljs">Cellphone(brand=Samsung, price=1299.99)cellphone1 == cellphone2 ? true</code></pre><h2 id="六单例类">六、单例类</h2><p>使用单例可以避免创建重复的对象，保证一个类最多拥有一个实例。</p><p>在<strong>Java</strong>中创建单例类需要以下几个步骤：</p><ol type="1"><li>将类的<strong>构造函数私有化</strong></li><li>向外部提供一个<code>getInstance()</code>的<strong>静态方法</strong>用于获取该类实例</li><li>在<code>getInstance()</code>中，判断如果当前缓存的实例为<code>null</code>，就创建一个新的实例并将其缓存，否则直接返回缓存的实例即可。</li></ol><p>在<strong>Kotlin</strong>中，只需要将<code>class</code>关键字改成<code>object</code>关键字即可声明单例类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> Singleton &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;test is called&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//调用方式</span><br>Singleton.test()<br></code></pre></td></tr></table></figure><p>看上去就像是调用了静态方法，其实是Kotlin在背后自动创建了一个类的实例，并且保证全局只有一个该类的实例。</p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Kotlin</tag>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Kotlin】学习笔记（一）变量、函数与逻辑控制</title>
    <link href="/2023/02/01/kotlin/kotlin-20230201/"/>
    <url>/2023/02/01/kotlin/kotlin-20230201/</url>
    
    <content type="html"><![CDATA[<h2 id="一变量">一、变量</h2><h3 id="定义方法">1.定义方法</h3><p>在Kotlin中，我们使用关键字<code>val</code>或<code>var</code>来声明一个变(常)量。</p><pre><code class="hljs">val: 声明一个常量，相当于java中的final变量，无法二次赋值var: 声明一个变量</code></pre><p>用例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = <span class="hljs-number">114</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">5.14</span><br></code></pre></td></tr></table></figure><p>Kotlin具备优秀的类型推导能力，它会将a的类型推导为Int，并将b的类型推导为Double。</p><h3 id="变量类型">2.变量类型</h3><p>例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a : <span class="hljs-built_in">Int</span> = <span class="hljs-number">114514</span> <span class="hljs-comment">//正确</span><br><span class="hljs-keyword">val</span> b : <span class="hljs-built_in">Int</span> = <span class="hljs-number">1919.810</span> <span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><p>Kotlin部分的对象数据类型如下： |类型对象|名称| |----|----| |Int|整形| |Long|长整型| |Short|短整型| |Float|单精度浮点型| |Double|双精度浮点型| |Boolean|布尔型| |Char|字符型| |Byte|字节型| |Number|数值型| |String|字符串型|</p><h2 id="二函数">二、函数</h2><h3 id="基本定义">1.基本定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> 函数名<span class="hljs-params">(参数a: 类型<span class="hljs-type">a</span>，参数<span class="hljs-type">b</span>: 类型<span class="hljs-type">b</span>)</span></span>: 返回值类型 &#123;<br>    <span class="hljs-keyword">return</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><p>特别地，当函数中只有一行代码时，可以不写花括号 <code>&#123;&#125;</code>，而使用 <code>=</code> 进行简化。如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>, num2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = max(num1, num2)<br></code></pre></td></tr></table></figure><p>在这种写法下，还能省去返回值类型的声明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>, num2: <span class="hljs-type">Int</span>)</span></span> = max(num1, num2)<br></code></pre></td></tr></table></figure><p>另外，函数中声明的参数默认是可变的，如果想让它不可更改，可以在前面添加关键字<code>val</code></p><h2 id="三逻辑控制">三、逻辑控制</h2><h3 id="if语句">1.if语句</h3><p>和大部分语言中的<code>if</code>基本没有区别</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">4</span><br><span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>    a = b<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b &gt; a)&#123;<br>    b = a<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    a = <span class="hljs-number">9</span><br>    b = <span class="hljs-number">9</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但在Kotlin中，<code>if</code>语句还有别的功能: 具有返回值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largerNumber</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>, num2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">val</span> value = <span class="hljs-keyword">if</span> (num1 &gt; num2) &#123; num1 &#125; <span class="hljs-keyword">else</span> &#123; num2 &#125;<br>    <span class="hljs-keyword">return</span> value<br>&#125;<br><br><span class="hljs-comment">//继续简化：</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largerNumber</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>, num2: <span class="hljs-type">Int</span>)</span></span> = <span class="hljs-keyword">if</span> (num1 &gt; num2) &#123;<br>    num1 <br>&#125; <span class="hljs-keyword">else</span> &#123; <br>    num2 <br>&#125;<br><br><span class="hljs-comment">//再简化：</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largerNumber</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>, num2: <span class="hljs-type">Int</span>)</span></span> = <span class="hljs-keyword">if</span> (num1 &gt; num2) num1 <span class="hljs-keyword">else</span> num2<br><br></code></pre></td></tr></table></figure><h3 id="when语句">2.when语句</h3><p><code>when</code>语句类似Java中的<code>switch</code>，但更加完善、简洁</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScore</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = <span class="hljs-keyword">when</span>(name) &#123;<br>    <span class="hljs-string">&quot;Tom&quot;</span> -&gt; <span class="hljs-number">86</span><br>    <span class="hljs-string">&quot;Jim&quot;</span> -&gt; <span class="hljs-number">77</span><br>    <span class="hljs-string">&quot;Jack&quot;</span> -&gt; <span class="hljs-number">95</span><br>    <span class="hljs-keyword">else</span> -&gt; &#123;<br>        println(<span class="hljs-string">&quot;Error&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，可以不在<code>when</code>中传入参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScore</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = <span class="hljs-keyword">when</span> &#123;<br>    name == <span class="hljs-string">&quot;Tom&quot;</span> -&gt; <span class="hljs-number">86</span>  <span class="hljs-comment">//不需要像Java那样使用 .equal() 对字符串进行判断</span><br>    name == <span class="hljs-string">&quot;Jim&quot;</span> -&gt; <span class="hljs-number">77</span><br>    name.startWith(<span class="hljs-string">&quot;Jack&quot;</span>) -&gt; <span class="hljs-number">95</span> <span class="hljs-comment">//箭头的左边可以换成所有带布尔返回值的表达式</span><br>    <span class="hljs-keyword">else</span> -&gt; &#123;<br>        println(<span class="hljs-string">&quot;Error&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>when语句还支持类型匹配：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkNumber</span><span class="hljs-params">(num: <span class="hljs-type">Number</span>)</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (num) &#123;<br>        <span class="hljs-keyword">is</span> <span class="hljs-built_in">Int</span> -&gt; println(<span class="hljs-string">&quot;num is Int&quot;</span>)<br>        <span class="hljs-keyword">is</span> <span class="hljs-built_in">Double</span> -&gt; println(<span class="hljs-string">&quot;num is Double&quot;</span>)<br>        <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;num not support&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for循环">3.for循环</h3><p>首先，Kotlin中移除了<code>for-i</code>循环，但加强了<code>for-each</code>循环。还引入了<strong>区间</strong>的概念。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> range1 = <span class="hljs-number">0.</span><span class="hljs-number">.10</span>              <span class="hljs-comment">//表示[0,10]的整数数组，双端闭区间</span><br><span class="hljs-keyword">val</span> range2 = <span class="hljs-number">0</span> until <span class="hljs-number">10</span>         <span class="hljs-comment">//表示[0,10)，左闭右开</span><br><span class="hljs-keyword">val</span> range3 = <span class="hljs-number">0</span> until <span class="hljs-number">10</span> step <span class="hljs-number">2</span>  <span class="hljs-comment">//step关键字，设置递增</span><br></code></pre></td></tr></table></figure><p><code>..</code> 和 <code>until</code>都要符合左端小于等于右端，无法创造递减区间。 如果要创造一个降序区间，要使用关键字 <code>downTo</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> range4 = <span class="hljs-number">10</span> downTo <span class="hljs-number">1</span>        <span class="hljs-comment">//[10,1]的降序区间，双端闭区间</span><br></code></pre></td></tr></table></figure><p>有了区间之后，就可以通过<code>for-in</code>循环来遍历这个区间：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.10</span>) &#123; <span class="hljs-comment">//在for循环中定义的循环变量无需使用var或val关键字</span><br>    println(i)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="while循环">4.while循环</h3><p>Kotlin中的<code>while</code>循环和Java中的没有任何区别：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) &#123;<br>    i++<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，<code>do-while</code>循环也一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br><span class="hljs-keyword">do</span>&#123;<br>    i++<br>&#125;<span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">10</span>)<br>println(i)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Kotlin</tag>
      
      <tag>变量</tag>
      
      <tag>函数</tag>
      
      <tag>逻辑控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于该博客的评论区</title>
    <link href="/2023/01/12/other-20230112/"/>
    <url>/2023/01/12/other-20230112/</url>
    
    <content type="html"><![CDATA[<p>本博客由 <a href="valine.js.org">Valine</a> 提供的评论区支持，依赖 <a href="https://en.gravatar.com/">Gravatar</a> 头像服务。评论时<strong>必须</strong>填入昵称。另外，填写注册过Gravatar的邮箱即可显示自定义头像。</p><p><strong>大致使用流程：</strong></p><ol type="1"><li><p>注册：进入 <a href="https://en.gravatar.com/">Gravatar</a> 网站，点击页面的Sign Up进行注册。</p></li><li><p>验证：进入你的邮箱，从Gravatar发出的信件中拷贝那段链接地址，在浏览器输入。</p></li><li><p>设置昵称、密码。</p></li><li><p>选择上传图片：一般都是从电脑中上传（My computer’s hard drive）。</p></li><li><p>剪裁大小</p></li><li><p>评级：你的头像要被分级的，因为可能会有朋友喜欢用比较曝露的头像，会影响小朋友身心健康的说。如果你的图片不是特别那个的话，一般不用选择Sex或暴力之类的，直接选择G（通用型），这样基本任何网站都能显示这个等级的图片。异次元比较邪恶，暂时允许显示R级以下的头像…</p></li><li><p>等待审核：可能需要站方短暂审核一下，一般选择了G，而你的图片没什么特别的，很快就通过。一般遇上慢的情况也就10分钟左右。</p></li></ol><p>完成了以上步骤，今后在支持Gravatar的网站留言都会显示你帅帅的头像了。</p><p>原文链接：<a href="https://blog.csdn.net/z_johnny/article/details/104211572/" class="uri">https://blog.csdn.net/z_johnny/article/details/104211572/</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>评论</tag>
      
      <tag>头像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】人物跳跃卡墙Bug的解决方法</title>
    <link href="/2023/01/12/unity/unity-20230112/"/>
    <url>/2023/01/12/unity/unity-20230112/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>发现人物在跳跃时如果碰到墙壁，会卡住不动。</p><figure><img src="/img/post/20230112/01-smil.png" alt="" /><figcaption>卡墙</figcaption></figure><p>原因是人物的RigidBody没有物理材质，导致其产生的摩擦力无限大，造成了卡墙现象</p><figure><img src="/img/post/20230112/02-smil.png" alt="" /><figcaption>人物的RigidBody2D</figcaption></figure><h2 id="问题解决">问题解决</h2><p>给人物设置两个物理材质，一个有摩擦，一个无摩擦。</p><p>在人物跳跃时切换无摩擦材质，其他情况切换有摩擦的材质。</p><figure><img src="/img/post/20230112/03-smil.png" alt="" /><figcaption>两种材质</figcaption></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//物理材质</span><br><span class="hljs-keyword">public</span> PhysicsMaterial2D pm_normal; <br><span class="hljs-keyword">public</span> PhysicsMaterial2D pm_jump; <span class="hljs-comment">//跳跃时切换无摩擦力，防止卡墙</span><br><br><span class="hljs-keyword">private</span> RigidBody2D rig;<br>...<br><span class="hljs-keyword">if</span> (落地条件) &#123;<br>    rig.sharedMaterial = pm_normal;<br>&#125;<br><br><span class="hljs-keyword">if</span> (跳跃条件) &#123;<br>    rig.sharedMaterial = pm_jump;<br>&#125;<br></code></pre></td></tr></table></figure><p>挺取巧的一个办法，就当作是简单的补丁先用着吧。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Bug</tag>
      
      <tag>跳跃</tag>
      
      <tag>卡墙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】因使用混合树而导致的奇怪Bug(已修复)</title>
    <link href="/2023/01/11/unity/unity-20230111/"/>
    <url>/2023/01/11/unity/unity-20230111/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>今天使用Unity时发现：<strong>物体没有按照动画设置的参数运动</strong>。</p><p>我为人物设置了攻击动画，由于人物不对称，故左右独立设置。如图是其中一段动画，其中设置了攻击区域触发器的变化动画。</p><span id="more"></span><figure><img src="/img/post/20230111/01-smil.png" alt="" /><figcaption>应当正确显示的情况</figcaption></figure><p>但当我运行时，<strong>攻击区域触发器却发生了奇怪的位移</strong>，跟动画clip中的设置不一致。</p><figure><img src="/img/post/20230111/02-smil.png" alt="" /><figcaption>运行后发现攻击触发器的位置不正确</figcaption></figure><p></br></p><h2 id="问题排查">问题排查</h2><p>经过2小时的折磨，在同学的帮助下终于锁定问题关键：</p><table><thead><tr class="header"><th><img src="/img/post/20230111/03-smil.png" alt="03.jpg" /></th><th><img src="/img/post/20230111/05-smil.png" alt="05.jpg" /></th></tr></thead><tbody></tbody></table><p>我使用了 <strong>混合树</strong> 来控制人物的左右攻击，恰恰就是这个混合树出了问题。</p><p>结论就是：<strong>混合树将我的左右两个动画的攻击区域触发器的各项参数进行混合，其中就包括了触发器形状的offset</strong>！这导致两个动画各自触发器形状的offset叠加而抵消，使其最后显示的<strong><em>offset的x值始终在0附近</em></strong>。</p><p></br></p><h2 id="问题解决">问题解决</h2><p>最后简单粗暴地解决了：放弃使用混合树控制左右动画。经过检验这样是可行的。</p><figure><img src="/img/post/20230111/04-smil.png" alt="" /><figcaption>弃用混合树</figcaption></figure><p>原本我使用混合树仅仅只是想优化一下拓扑结构。。。现在不能这么玩了。</br></p><p>我创建了子状态机，然后把攻击动画的逻辑全塞里面。。。让他看起来。。额。。至少没这么复杂(大概)。</p><table><thead><tr class="header"><th><img src="/img/post/20230111/06-smil.png" alt="06.jpg" /></th><th><img src="/img/post/20230111/07-smil.png" alt="07.jpg" /></th></tr></thead><tbody></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>混合树</tag>
      
      <tag>Bug</tag>
      
      <tag>动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
