<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【Django+微信小程序】前后端分离跨站点POST请求踩坑实录</title>
    <link href="/2023/05/15/django-20230515/"/>
    <url>/2023/05/15/django-20230515/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>django版本3.2 在做前后端分离项目过程中需要用到跨站点POST请求，但会被django拦截。尽管将<code>settings.py</code>中的<code>django.middleware.csrf.CsrfViewMiddleware</code>注释掉可以解决，但在正式部署的情况下是不能这么做的，因为这会导致全局的csrf防护失效从而出现漏洞。</p><h2 id="解决方案">解决方案</h2><p>在settings.py中添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">CSRF_TRUSTED_ORIGINS = [<span class="hljs-string">&#x27;servicewechat.com&#x27;</span>] <br><span class="hljs-comment">#这是微信小程序的官方服务器域名，所有请求都从这里发出</span><br></code></pre></td></tr></table></figure><p>首先要使前后端能交流csrftoken和cookie:</p><p><strong>Django后端：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># xxx/views.py</span><br><span class="hljs-keyword">from</span> django.middleware.csrf <span class="hljs-keyword">import</span> get_token<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">token</span>(<span class="hljs-params">request</span>):<br>    token=get_token(request)<br>    <span class="hljs-keyword">return</span> JsonResponse(&#123;<span class="hljs-string">&#x27;token&#x27;</span>:token&#125;)<br><br><span class="hljs-comment"># xxx/urls.py</span><br><span class="hljs-comment"># 添加：</span><br>path(<span class="hljs-string">&#x27;token&#x27;</span>, views.token)<br></code></pre></td></tr></table></figure><p><strong>微信js前端：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getToken</span>(<span class="hljs-params">callback</span>) &#123;<br>  wx.<span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-title class_">DBPath</span> + <span class="hljs-string">&#x27;token&#x27;</span>,<br>    <span class="hljs-attr">success</span>:<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">if</span>(callback)<br>        <span class="hljs-title function_">callback</span>(res);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在小程序启动或者登录的时候向后端发送获取<code>csrftoken</code>的请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getToken</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    <span class="hljs-keyword">let</span> temp = (res.<span class="hljs-property">cookies</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;;&#x27;</span>)[<span class="hljs-number">0</span>]).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//split(&#x27;;&#x27;)[0]是因为csfttoken总是被django放在最前面</span><br>    wx.<span class="hljs-title function_">setStorageSync</span>(<span class="hljs-string">&#x27;csrftoken&#x27;</span>, res.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>);<br>    wx.<span class="hljs-title function_">setStorageSync</span>(<span class="hljs-string">&#x27;cookie&#x27;</span>, res.<span class="hljs-property">header</span>[<span class="hljs-string">&#x27;Set-Cookie&#x27;</span>]);<br>&#125;)<br></code></pre></td></tr></table></figure><p>在js的POST请求中添加请求头(以<code>wx.uploadFile</code>为例):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">wx.<span class="hljs-title function_">uploadFile</span>(&#123;<br>    <span class="hljs-attr">filePath</span>: path,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;file&#x27;</span>,<br>    <span class="hljs-attr">header</span>: &#123; <span class="hljs-comment">//必须包含cookie和X-CSRFToken</span><br>        <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>,<br>        <span class="hljs-comment">//上网找的解决方案都缺少这个cookie，我这边必须加上这个</span><br>        <span class="hljs-comment">//否则csrf cookie not set</span><br>        <span class="hljs-string">&#x27;cookie&#x27;</span>: wx.<span class="hljs-title function_">getStorageSync</span>(<span class="hljs-string">&#x27;cookie&#x27;</span>),<br>        <span class="hljs-string">&#x27;X-CSRFToken&#x27;</span>:  wx.<span class="hljs-title function_">getStorageSync</span>(<span class="hljs-string">&#x27;csrftoken&#x27;</span>) <br>    &#125;,<br>    <span class="hljs-attr">formData</span>:&#123;<br>        ...<br>    &#125;,<br>    <br>    <span class="hljs-attr">url</span>: <span class="hljs-title class_">DBPath</span> + <span class="hljs-string">&#x27;upload-avatar&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>微信小程序</tag>
      
      <tag>CSRF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Django】宝塔+Django3+uwsgi+nginx+MySQL部署踩坑实录</title>
    <link href="/2023/04/22/django-20230422/"/>
    <url>/2023/04/22/django-20230422/</url>
    
    <content type="html"><![CDATA[<p>待补充</p><h2 id="一服务器与宝塔面板">一、服务器与宝塔面板</h2><h3 id="镜像挑选">1. 镜像挑选</h3><p>这里我在腾讯云选购了亚太地区的服务器，选宝塔的应用模板。 选用宝塔是想降低部署难度。</p><figure><img src="img/post/20230422/01.png" alt="" /><figcaption>宝塔实例</figcaption></figure><h3 id="更改root密码">2. 更改root密码</h3><p>在<code>更多 -&gt; 重置密码</code>里面重置root的密码</p><h3 id="配置宝塔面板">3. 配置宝塔面板</h3><p>实例启动之后，放行宝塔的端口</p><figure><img src="img/post/20230422/02.png" alt="" /><figcaption>放行宝塔端口</figcaption></figure><p>查看宝塔的账号密码：</p><blockquote><p>/etc/init.d/bt default</p></blockquote><p>会看到: &gt;宝塔面板 &gt; &gt;外网面板地址: http://<strong>.</strong>.<em><strong>.</strong>:8888/</em>******* &gt;内网面板地址: http://<strong>.<em>.</em>.</strong>:8888/******** &gt; &gt;宝塔后台的用户名密码 &gt;username: ******* &gt;password: ********</p><p>根据上面的信息,进入宝塔面板,输入账号密码,然后有三件要做的事:</p><ol type="1"><li><p>注册并绑定宝塔账号</p></li><li><p>你安装LAMP, 选左边带nginx的安装</p></li><li><p>配置好你实例的镜像,按他的提示来就可以了</p></li></ol><h2 id="二mysql配置">二、MySQL配置</h2><p>自带MySQL的版本是<code>5.7</code></p><h3 id="创建数据库">1. 创建数据库</h3><h3 id="放行3306端口">2. 放行3306端口</h3><p><strong>宝塔面板</strong>和<strong>腾讯云</strong>的都要放行</p><h3 id="更改访问权限">3. 更改访问权限</h3><p>更改成所有人可访问</p><h3 id="测试连接">4. 测试连接</h3><p>我这里分别使用自带的phpMyAdmin和本地的SQLyog进行测试</p><h2 id="三django配置">三、Django配置</h2><h3 id="创建virtualenv虚拟环境">1. 创建virtualenv虚拟环境</h3><p>该实例自带两个python版本<code>python2(.7)</code>和<code>python3(.6)</code></p><p>为了避免权限问题, 我选择直接在<code>/www</code>下创建: &gt; cd /www/wwwroot/django</p><h3 id="配置需要用到的库">2. 配置需要用到的库</h3><blockquote><p>pip install django pymysql mysqlclien</p></blockquote><h3 id="创建一个测试项目">3. 创建一个测试项目</h3><h2 id="四uwsgi配置">四、uwsgi配置</h2><h3 id="配置uwsgi.ini">1. 配置uwsgi.ini</h3><p>在<code>manage.py</code>同级目录中创建<code>uwsgi.ini</code>,内容如下:</p><h3 id="安装uwsgi">2. 安装uwsgi</h3><blockquote><p>yum python-devel pip install uwsgi</p></blockquote><h3 id="测试uwsgi">3. 测试uwsgi</h3><h2 id="五nginx反向代理">五、nginx反向代理</h2><h2 id="六ssh连接测试">六、ssh连接测试</h2>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>uwsgi</tag>
      
      <tag>nginx</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Kotlin】学习笔记（六）扩展函数、运算符重载</title>
    <link href="/2023/04/17/kotlin/kotlin-20230417/"/>
    <url>/2023/04/17/kotlin/kotlin-20230417/</url>
    
    <content type="html"><![CDATA[<h2 id="一扩展函数">一、扩展函数</h2><ul><li><p>扩展函数可以在<strong>不修改类的定义的情况下，为类增加新的功能</strong>，可以为自定义类扩展，也可以扩展内置的类如<code>String、List</code></p></li><li><p>扩展函数的语法结构</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> ClassName.<span class="hljs-title">methodName</span><span class="hljs-params">(param1: <span class="hljs-type">Int</span>, param2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果要给String类增加一个<code>letterCount</code>方法对字符串中字母的数量进行统计：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">lettersCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> (char <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (char.isLetter()) &#123;<br>            count++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure><p>便可以进行使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">println(<span class="hljs-string">&quot;Adjkr#ip==1&quot;</span>.lettersCount()) <br><span class="hljs-comment">// &gt;&gt; 7</span><br></code></pre></td></tr></table></figure><h2 id="二运算符重载">二、运算符重载</h2><ul><li>使用运算符重载可以<strong>重新定义已有的运算符，赋予其另一种功能</strong>，以适应不同的数据类型。</li></ul><h3 id="使用operator进行重载">使用operator进行重载</h3><ul><li>以为<code>Vector</code>类重载加号运算符为例：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>(<span class="hljs-keyword">var</span> x: <span class="hljs-built_in">Float</span>, <span class="hljs-keyword">var</span> y: <span class="hljs-built_in">Float</span>) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(b: <span class="hljs-type">Vector</span>)</span></span>: Vector &#123;<br>        <span class="hljs-keyword">return</span> Vector(<span class="hljs-keyword">this</span>.x+b.x, <span class="hljs-keyword">this</span>.y+b.y)<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(<span class="hljs-subst">$&#123;this.x&#125;</span>, <span class="hljs-subst">$&#123;this.y&#125;</span>)&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = Vector(<span class="hljs-number">1f</span>, <span class="hljs-number">2f</span>)<br>    <span class="hljs-keyword">val</span> b = Vector(<span class="hljs-number">2f</span>, <span class="hljs-number">3f</span>)<br>    <span class="hljs-keyword">val</span> c = a + b<br>    println(c)<br>    <span class="hljs-comment">// &gt;&gt; (3.0, 5.0)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运算符方法名对照表">运算符方法名对照表</h3><figure><img src="../img/post/20230417/operator_name.png" alt="" /><figcaption>对照表</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
      <tag>笔记</tag>
      
      <tag>扩展函数</tag>
      
      <tag>运算符重载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据库】课堂笔记（二）关系模型与关系代数</title>
    <link href="/2023/03/04/database-20230304/"/>
    <url>/2023/03/04/database-20230304/</url>
    
    <content type="html"><![CDATA[<h2 id="一关系模型">一、关系模型</h2><ul><li>关系数据库系统：<strong>RDBMS</strong>，支持关系数据模型的数据库系统，当今的主流数据库管理系统。</li><li>关系模型的构成：由<strong>关系数据结构</strong>、<strong>关系操作集合</strong>和<strong>关系完整性约束</strong>三部分组成。</li></ul><h3 id="关系数据结构">1. 关系数据结构</h3><h4 id="关系">1. 关系</h4><ul><li>关系模型的数据结构简单，即二维表，亦称为关系</li><li>关系数据库：表的集合，即关系的集合。</li><li>表：一个实体集，一行就是一个实体，它由共同表示一个实体的相关联的若干属性的值所构成。</li></ul><h4 id="关系模式">2. 关系模式</h4><p>关系模式：描述关系，形式化表示：<code>r(U, D, DOM, F)</code> 。</p><ul><li>r：关系名；</li><li>U：组成关系的属性名的集合；</li><li>D：属性集U中所有属性所来自的域的集合；</li><li>DOM：属性向域的映像集合；</li><li>F：属性间数据依赖关系集合(元组各属性取值之间的关联性)。</li></ul><h4 id="关系与关系模式联系区别">3. 关系与关系模式联系区别</h4><ul><li>对于一个二维表，有表头部分和表体部分。<ul><li><code>表头部分</code>：定义表的结构，即定义表由哪些列构成(假设由n列构成)，每个列的名字和取值范围等；</li><li><code>表体部分</code>：所有数据行(元组)的集合，每个数据行都是由表头部分规定的n列有关联的取值的集合构成。</li></ul></li><li><strong>关系：</strong> 对应<code>表体部分</code>，每个数据行对应关系的一个元组，即关系是元组的集合。关系是 <strong>值</strong> 的概念。</li><li><strong>关系模式：</strong> 对应<code>表头部分</code>，定义元组集合的结构，即定义一个元组由哪些属性构成，每个属性的名字和取值域等。 关系模式是 <strong>型</strong> 的概念。</li></ul><h4 id="码">4. 码</h4><p><strong>超码：</strong> 关系r中的一个或多个属性的集合A，若A可以<code>唯一地标识</code>关系r中的一个元组，则称属性集A为关系r的一个超码 (superkey) 。</p><p><strong>候选码：</strong> 关系r的一个或多个属性的集合A，若A是关系r的超码，且A的任意真子集都不能成为关系r的超码，则称属性集A为候选码 (candidate key) 。</p><p><strong>主码：</strong> <u>若一个关系有多个候选码</u>，则可以选定其中的一个候选码作为该关系的主码 。</p><p><strong>外码：</strong> 设F是关系r的一个属性(或属性集)，Ks是关系s的主码。如果F与Ks相对应(即关系r中属性F的取值范围对应于关系s中主码Ks的取值范围的子集)，则称F是关系r参照关系s的外码(foreign key)，简称F是关系r的外码。</p><h3 id="关系完整性约束">2. 关系完整性约束</h3><h4 id="实体完整性">1. 实体完整性</h4><div class="note note-secondary">            <p>若属性集A是关系r的主码，则A<code>不能取空值null</code>。</p>          </div><h4 id="参照完整性">2. 参照完整性</h4><div class="note note-secondary">            <p>若属性(或属性集)F是关系r的外码，它与关系s的主码Ks相对应，则对于关系r中的每一个元组在属性F上的取值==要么为空值null，要么等于关系s中某个元组的主码值。</p>          </div><h4 id="用户自定义完整性">3. 用户自定义完整性</h4><div class="note note-secondary">            <p>针对<code>某一具体应用要求来定义的约束条件</code>，它反映某一具体应用所涉及的数据必须满足的语义要求。例如，</p><ul><li>限制关系中某些属性的取值符合业务语义要求。</li><li>限制关系中某些属性的取值之间满足一定的逻辑关系。</li><li>限制关系中某属性集上的取值必须唯一。</li></ul>          </div><h3 id="关系操作集合">3. 关系操作集合</h3><ul><li>关系操作的特点是<strong>集合操作方式</strong>，即操作的对象和结果都是集合。</li><li>操作方式也称为<strong>一次一个集合</strong>。</li><li>关系模型中的关系操作有<strong>查询操作</strong>和<strong>更新操作(插入、删除和修改)</strong>两大类 。<ul><li><strong>查询操作</strong>是关系操作中最主要的部分。查询操作又可以分为<code>选择</code>(select)、<code>投影</code>(project)、连接(join)、<code>除</code>(divide)、<code>并</code>(union)、<code>交</code>(intersection)、<code>差</code>(except)、<code>笛卡尔积</code>等。</li></ul></li><li>关系操作可用两种方式来表示 ——代数方式和逻辑方式。<ul><li><p><strong>关系代数：</strong> 用<code>代数方式</code>表达的关系查询语言。</p></li><li><p><strong>关系演算：</strong> 用<code>逻辑方式</code>表达的关系查询语言。关系演算又可按谓词变元的基本对象是元组变量还是域变量分为元组关系演算和域关系演算。</p></li><li><p>对于关系代数、元组关系演算和域关系演算均是抽象的查询语言，在表达能力上是完全等价的。</p></li></ul></li></ul><h2 id="二-关系代数">二、 关系代数</h2><p>关系代数通过关系代数运算构成的表达式来表达查询。 五种基本关系代数运算是：<code>∪，-，×，π和σ</code></p><h3 id="传统的集合运算">1. 传统的集合运算</h3><h4 id="并">1. 并</h4><ul><li><p>关系r与关系s的并记作 $${\color{Green} r} {\color{Red} \cup}  {\color{Green} s}  =\left \{{\color{Green} t} \mid{\color{Green} t} \in {\color{Green} r}\vee{\color{Green} t} \in {\color{Green} s}  \right \}$$</p></li><li><p>结果关系：n目关系，由属于r或属于s的所有元组组成。</p></li></ul><h4 id="差">2. 差</h4><ul><li><p>关系r与关系s的差记作 ： $${\color{Green} r} {\color{Red} -}  {\color{Green} s}  =\left \{{\color{Green} t} \mid{\color{Green} t} \in {\color{Green} r}\wedge{\color{Green} t} \notin {\color{Green} s}  \right \}$$</p></li><li><p>结果关系：n目关系，由属于r而不属于s的所有元组组成。</p></li></ul><h4 id="交">3. 交</h4><ul><li><p>关系r与关系s的交记作： $${\color{Green} r} {\color{Red} \cap}  {\color{Green} s}  =\left \{{\color{Green} t} \mid{\color{Green} t} \in {\color{Green} r}\wedge{\color{Green} t} \in {\color{Green} s}  \right \}$$</p></li><li><p>结果关系：n目关系，由既属于r又属于s的所有元组组成。等价表示：关系交可以通过差来表达，即 $${\color{Green} r} {\color{Red} \cap}  {\color{Green} s}  ={\color{Green} r} -\left({\color{Green} r} - {\color{Green} s}\right)$$</p></li></ul><h4 id="笛卡尔积">4. 笛卡尔积</h4><ul><li>两个分别为n目和m目的关系r和s的笛卡尔积是一个n+m目元组的集合。</li><li>元组的前n列是关系r的一个元组，后m列是关系s的一个元组。</li><li>若关系r有kr个元组，关系s有ks个元组，则关系r和s的笛卡尔积有kr×ks个元组。<code>笛卡尔积基数：kr*ks</code> $${\color{Green} r} {\color{Red} \times}  {\color{Green} s}  =\left \{{\color{Green} t_{r} } \cdot {\color{Green} t_{s}}\mid{\color{Green} t_{r}} \in {\color{Green} r}\wedge{\color{Green} t_{s}} \in {\color{Green} s}\right \}$$</li></ul><h3 id="专门的关系运算">2. 专门的关系运算</h3><h4 id="选择">1. 选择</h4><p>选择操作是在关系r中查找满足给定谓词（即选择条件）的所有元组，记作： $${\color{Red} \sigma_{{\color{Yellow} P} }} \left ( {\color{Green} r} \right ) =\left \{{\color{Green} t}  \mid {\color{Green} t}  \in\wedge{\color{Yellow} P} \left ({\color{Green} t} \right )\right \}$$ P：表示谓词(即选择条件)，它是一个逻辑表达式，取值为“真”或“假”。 说明：对关系从水平(行)角度进行运算，即选择操作。</p><h4 id="投影">2. 投影</h4><p>投影操作就是从关系r中选择若干属性列组成新的关系。 $${\color{Red} \Pi _{{\color{Yellow} A} }} ({\color{Green} r} ) = \{{\color{Green} t}[{\color{Green} A} ]  \mid {\color{Green} t}  \in {\color{Green} r} \}$$ A：为关系r的属性集合。 说明：对关系从纵向(列)的角度进行，即投影操作。</p><h4 id="连接">3. 连接</h4><p>连接也称θ连接。记为A op B，A、B分别为关系r和s中的属性个数相等且可比的连接属性集，op为比较运算符。 θ连接是从两个关系的笛卡尔积中选取连接属性间满足谓词θ的所有元组。 $${\color{Green} r} \, {\color{Red} \bowtie  _{{\color{Yellow} \theta } }} \, {\color{Green} s}  = \{{\color{Green} t_{r}} \cdot  {\color{Green} t_{s}} \mid {\color{Green} t_{s}}  \in {\color{Green} s} \wedge({\color{Green} r.A}  \, {\color{Yellow} op} \, {\color{Green} s.B} )\}$$</p><h4 id="象集非重点">4. 象集(非重点)</h4><p>给定关系r(A, B)，A和B是属性集。对任意t∈r，记t[A]=x，则在关系r中的属性集A的某个取值x的象集Bx定义： $${\color{Green} B} _{{\color{Yellow} x} } = \{ {\color{Green} t} {\color{Green} [B} ] \mid {\color{Green} t}  \in {\color{Green} r}  \wedge {\color{Green} t} [{\color{Green} A} ] = {\color{Yellow} x}  \}$$ 象集Bx的含义：表示关系r中属性集A上取值为x的所有元组在属性集B上的投影。</p><h4 id="除运算非重点">5. 除运算(非重点)</h4><p>设关系r®和s(S)，属性集S是R的子集，即S∈R，则关系r÷s是关系r中满足下列条件的元组在属性集R-S上的投影： trr，记 x= tr[R-S]，则关系r中属性集R-S的取值x的象集Sx包含关系s。记作 ： $${\color{Green} r} \, {\color{Red} {\div}}  \, {\color{Green} s} =\{ {\color{Green} t_{r}} [{\color{Purple} R-S} ] \mid {\color{Green} t_{r}}  \in {\color{Green} r}  \wedge{\color{Green} s}  \subseteq {\color{Green} S_{x}} \}$$</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库，笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Kotlin】学习笔记（五）泛型</title>
    <link href="/2023/03/01/kotlin/kotlin-20230301/"/>
    <url>/2023/03/01/kotlin/kotlin-20230301/</url>
    
    <content type="html"><![CDATA[<h2 id="一泛型方法">一、泛型方法</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">fromJson</span><span class="hljs-params">(json: <span class="hljs-type">String</span>, tClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T? &#123; <span class="hljs-comment">/*可空返回值*/</span><br>    <span class="hljs-keyword">val</span> instance: T? = tClass.newInstance()<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fromJson&lt;String&gt;(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, String::<span class="hljs-keyword">class</span>.java)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二泛型接口类">二、泛型接口/类</h2><h3 id="定义">1.定义</h3><p>定义<strong>泛型接口</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Drinks</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">taste</span><span class="hljs-params">()</span></span>: T<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">price</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>定义<strong>泛型类</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">var</span> t:T<span class="hljs-comment">/*泛型字段*/</span>) &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printColor</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用">2.使用</h3><p>继承泛型接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DrinkApple</span> : <span class="hljs-type">Drink</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">drink</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>        print(<span class="hljs-string">&quot;drink:<span class="hljs-subst">$&#123;s&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继承泛型类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlueColor</span>(<span class="hljs-keyword">val</span> color: String) : Color&lt;String&gt;(color) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printColor</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;printColor:<span class="hljs-subst">$&#123;color&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三泛型类型限定">三、泛型类型限定</h2><p>可以将泛型的<strong>范围限定为某个类及其子类</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//限定为JSONObject及其子类</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T: JSONObject&gt;</span> <span class="hljs-title">fromJson</span><span class="hljs-params">(json: <span class="hljs-type">String</span>, tClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T? &#123; <span class="hljs-comment">/*可空返回值*/</span><br>    <span class="hljs-keyword">val</span> instance: T? = tClass.newInstance()<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br><br><span class="hljs-comment">//传入的类型必须同时满足where子句的所有条件</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">fromJson</span><span class="hljs-params">(json: <span class="hljs-type">String</span>, tClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T? <span class="hljs-keyword">where</span> T : User, T: Comparable&lt;T&gt;&#123;<br>    <span class="hljs-keyword">val</span> instance: T? = tClass.newInstance()<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>in</code>, <code>out</code>关键字限定泛型类的上下限</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// Int 、 Long 都继承自Number</span><br>    <span class="hljs-keyword">val</span> l1 = ArrayList&lt;Number&gt;()<br>    l1.add(<span class="hljs-number">23</span>)    <br>    l1.add(<span class="hljs-number">1114</span>)<br>    <br>    <span class="hljs-keyword">val</span> l2 = ArrayList&lt;<span class="hljs-built_in">Long</span>&gt;()<br>    l2.add(<span class="hljs-number">1515461515545</span>)    <br>    l2.add(<span class="hljs-number">1114545124</span>)<br><br>    <span class="hljs-keyword">val</span> k1: ArrayList&lt;<span class="hljs-keyword">in</span> <span class="hljs-built_in">Int</span>&gt; = l1    <br>    <span class="hljs-keyword">val</span> k2: ArrayList&lt;<span class="hljs-keyword">out</span> Number&gt; = l2<br><br>    printArr(k1)<br>    printArr(k2)<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">printArr</span><span class="hljs-params">(arr : <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">for</span>(n <span class="hljs-keyword">in</span> arr) &#123;<br>        println(n)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
      <tag>笔记</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据库】课堂笔记（一）数据库系统概论</title>
    <link href="/2023/02/23/database-20230223/"/>
    <url>/2023/02/23/database-20230223/</url>
    
    <content type="html"><![CDATA[<h2 id="一数据与数据管理">一、数据与数据管理</h2><ol type="1"><li><p><strong>数据</strong></p><p>描述事物的符号记录称为<strong>数据</strong>。数据是数据库(DB)中存储的对象，也是数据库管理系统(DBMS)处理的对象。</p><p><strong>结构化数据</strong>：由数据库二维逻辑结构（表格）描述的数据。</p><p><strong>非结构化数据</strong>：不方便用数据库二维逻辑结构表现的数据，包括所有文档、文本、图片、音视频等。</p><p><strong>半结构化数据</strong>：介于完全结构化数据（关系型数据库，面向对象数据库中的数据）和完全无结构的数据（如自然语言文本、音视频、图像等）。如XML文档，数据的结构和内容混在一起。 <br/></p></li><li><p><strong>数据管理</strong></p><p><strong>数据处理</strong>：对各种数据进行采集、存储、加工、传播和应用等一系列活动的总和。从大量、可能杂乱无章、难以理解的数据中抽取并推导出对于某些特定的人们来说有价值、有意义的数据。</p><p><strong>数据管理</strong>：对数据进行有效的分类、组织、编码存储、检索、维护和应用，是数据处理的中心问题。 <br/></p></li></ol><h2 id="二数据管理技术发展的三个阶段">二、数据管理技术发展的三个阶段</h2><h3 id="人工管理阶段">1.人工管理阶段</h3><ul><li>数据不保存</li><li>数据不共享，数据冗余大</li><li>数据不具有独立性</li></ul><pre><code class=" mermaid">graph LR应用程序1---数据集1;应用程序2---数据集2;</code></pre><h3 id="文件系统阶段">2.文件系统阶段</h3><ul><li>数据以“文件”形式长期保存</li><li>按文件名访问，按记录进行存取</li><li>数据的逻辑结构与物理结构有了区别</li><li>数据面向应用</li></ul><pre><code class=" mermaid">graph LRa((存取方法))应用程序1 --- a;应用程序2 --- a;a --- 文件组1;a --- 文件组2;</code></pre><h3 id="数据库管理系统阶段">3.数据库管理系统阶段</h3><ul><li>使用数据库管理系统(DBMS)进行管理</li><li>数据面向整个应用系统</li><li>数据共享性高，冗余度小</li><li>数据具有高度的物理独立性和逻辑独立性</li><li>数据整体结构化，用数据模型描述</li><li>由数据库管理系统提供数据安全性、完整性、并发控制和恢复能力</li></ul><h2 id="三重要概念">三、重要概念</h2><h3 id="数据独立性">1. 数据独立性</h3><ul><li><p>数据独立：数据的使用（应用程序）与数据的说明（数据组织结构与存储方式）分离，使数据的组织和存储结构（在一定范围内）变更时不必修改应用程序。</p></li><li><p>物理独立性：用户的应用程序在一定程度上独立于数据库中数据的物理<strong>存储</strong>结构。（数据在<strong>物理存储结构</strong>上的改变不需要相应修改程序）</p></li><li><p>逻辑独立性：用户的应用程序在一定程度上独立于数据库中数据的全局逻辑（<strong>组织</strong>）结构。（<strong>数据库总体逻辑结构</strong>的改变不需要相应修改程序）</p></li></ul><h3 id="数据冗余">2. 数据冗余</h3><ul><li>相同数据在不同地方<strong>重复存储</strong>。</li></ul><h3 id="完整性">3. 完整性</h3><ul><li>指数据的正确性、有效性和相容性，也称为一致性约束。（如必须满足某个规定才能插入新数据）</li></ul><h3 id="整体结构化">4.整体结构化</h3><ul><li>数据库的<strong>主要特征</strong>之一，也是数据库管理系统与文件按系统的本质区别。</li><li>指数据不仅仅是内部结构化，而是将<strong>数据以及数据之间的联系统一管理</strong>起来，使之结构化。（如几张数据表之间存在一致性约束）</li><li>指在数据库中的数据不仅仅针对某一个应用，而是<strong>面向全（相关）组织的所有应用</strong>。（一份数据供多个相关应用使用）</li></ul><h3 id="数据库管理系统dbms">5. 数据库管理系统(DBMS)</h3><ul><li>由一个<strong>相互关联的数据的集合</strong>和一组<strong>用以访问、管理和控制这些数据的程序</strong>组成。</li><li>该数据集合称为<strong>数据库</strong>。</li><li>DBMS能提供一个方便且高效地存取、管理和控制数据库信息的环境。</li><li>DBMS的特点：<ul><li>数据（整体）<strong>结构化</strong></li><li>数据<strong>共享度高，冗余度低</strong>，易扩充</li><li>数据<strong>独立性高</strong></li></ul></li></ul><h2 id="四数据模型">四、数据模型</h2><h3 id="概念">1. 概念</h3><p>数据模型是一个<strong>描述数据结构、数据操作以及数据约束</strong>的数学形式体系。数据结构用于刻画数据、数据语义以及数据之间的联系；数据约束是对数据结构和数据操作的一致性、完整性约束。</p><h3 id="分层">2. 分层</h3><p>根据<strong>数据抽象的不同级别</strong>，将数据模型分为3层：</p><pre><code class=" mermaid">flowchart TB    a1((现实世界));    subgraph 数据模型        b1[概念模型];        c1[逻辑模型];        d1[物理模型];                b1--数据库设计工具协助设计人员--&gt;c1;        c1--DBMS--&gt;d1;    end    a1--数据库设计人员--&gt;b1;</code></pre><ol type="1"><li><strong>概念模型</strong><ul><li>按用户的观点或认识对现实世界的数据和信息进行建模，主要<strong>用于数据库设计</strong>。</li><li>特点：语义表达能力强；易于理解；独立于任何DBMS；容易转换成不同DBMS所支持的逻辑数据模型。</li><li>常用：<strong>E-R模型</strong>（实体-联系模型）、<strong>OO模型</strong>（面向对象模型） <br></li></ul></li><li><strong>逻辑模型</strong><ul><li>是用户通过DBMS看到的现实世界，是按计算机系统的观点对数据建模，即计算机的实现形式，主要<strong>用于DBMS的实现</strong>。</li><li>特点：既要考虑用户容易理解，又要考虑便于DBMS的实现。</li><li>常用：传统模型（层次模型、网状模型、关系模型）、面向对象模型（XML模型）。 <br></li></ul></li><li><strong>物理模型</strong><ul><li>数据抽象的最底层，用来<strong>描述数据的物理存储结构和存取方法</strong>。</li><li>特点：不仅由DBMS的设计决定，还于操作系统、计算机硬件密切相关。数据库设计人与要了解和选择物理模型，一般用户则不必考虑。</li></ul></li></ol><h3 id="组成要素">3. 组成要素</h3><ol type="1"><li><strong>数据结构</strong> 描述<strong>数据库的组成对象以及对象之间的关系</strong>。是对系统<strong>静态特性</strong>的描述。 <br></li><li><strong>数据操作</strong> 指对数据库中各种对象的实例（类的实例）<strong>允许执行的操作集合</strong>（增删改查），包括相关操作规则。是对系统<strong>动态特性</strong>的描述。 <br></li><li><strong>数据完整性约束</strong> 是<strong>一组数据完整性规则</strong>,用以限定符合数据模型的数据库状态以及状态的变化，以<strong>确保数据的正确、有效和相容</strong>。</li></ol><h3 id="层次模型">4. 层次模型</h3><p>层次模型用<strong>树形结构</strong>标识各类实体以及实体间的联系。</p><p><strong>特征：</strong></p><ol type="1"><li>有且仅有一个节点没有父节点，即根节点</li><li>根以外的其他节点有且仅有一个父节点</li></ol><figure><img src="img/post/20230223/%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B.jpg" alt="" /><figcaption>层次模型</figcaption></figure><p><strong>优点：</strong></p><ol type="1"><li>结构简单、清晰、明朗</li><li>查询效率较高</li><li>提供了较好的数据完整性支持</li></ol><p><strong>缺点：</strong></p><ol type="1"><li>结构呆板，缺乏灵活性</li><li>层次数据模型只能表示实体之间的一对多的关系，<strong>不能表示多对多的复杂关系</strong>，因此现实世界中的很多模型不能通过该模型方便的表示</li><li>查询节点的时候必须知道其双亲节点的，限制了对数据库存取路径的控制</li></ol><h3 id="网状模型">5. 网状模型</h3><p>网关模型用<strong>有向图</strong>表示实体和实体之间的联系。</p><p><strong>特征：</strong></p><ol type="1"><li>可以存在两个或者多个节点没有父节点</li><li>允许单个节点存在多于一个父节点</li></ol><figure><img src="img/post/20230223/%E7%BD%91%E7%8A%B6%E6%A8%A1%E5%9E%8B.jpg" alt="" /><figcaption>网状模型</figcaption></figure><p><strong>优点：</strong></p><ol type="1"><li>可以更直观地直接描述现实世界</li><li>具有良好的性能，存取效率较高</li></ol><p><strong>缺点：</strong></p><ol type="1"><li><strong>结构复杂</strong>，不利于最终用户掌握</li><li>操作语言比较复杂</li></ol><h3 id="关系模型">6. 关系模型</h3><p>使用<strong>表格</strong>表示实体和实体之间关系的数据模型</p><p><strong>特征：</strong></p><ol type="1"><li>关系数据模型中，无论是是实体、还是实体之间的联系都是被映射成统<strong>二维表</strong>关系，在关系模型中，操作的对象和结果都是一张二维表</li><li>关系型数据库可用于表示实体之间的多对多的关系，只是此时要<strong>借助第三个关系表</strong>，来实现多对多的关系</li><li>关系必须是规范化的关系，即每个属性是不可分割的实体，<strong>不允许表中表</strong>的存在</li></ol><figure><img src="img/post/20230223/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B.jpg" alt="" /><figcaption>关系模型</figcaption></figure><p>可以看到学生与课程之间的联系以及教师和课程之间的多对多联系都被映射成了表格。其中选课表中的sut_id和cour_id分别是引用学生表和课程表的cour_id的外键；教课表也是如此。</p><p><strong>优点：</strong></p><ol type="1"><li>建立在严格的数学概念的基础上，有关系代数作为语言模型，有关系数据理论作为理论基础</li><li>概念单一，实体、实体的联系以及对数据操作的结果都是关系，故结构简单清晰，易用</li><li>存取路径相对透明，从而数据独立性更高，安全保密性更好，简化了程序员工作，提高了开发和维护效率</li></ol><p><strong>缺点：</strong></p><ol type="1"><li>存取路径相对透明，导致查询效率往往不如非关系数据模型</li></ol><h2 id="五数据抽象与数据库三级模式">五、数据抽象与数据库三级模式</h2><h3 id="数据抽象层次">1. 数据抽象层次</h3><ol type="1"><li><p><strong>视图层</strong>：描述数据库的某个部分，是数据库的局部逻辑结构（取出数据库中的部分数据）</p></li><li><p><strong>逻辑层</strong>：描述数据库中存储什么数据以及这些数据的关系</p></li><li><p><strong>物理层</strong>：描述数据的存储结构和存取方法</p></li></ol><h4 id="三级模式">2. 三级模式</h4><ol type="1"><li><p><strong>外模式</strong></p><ul><li>也称<strong>用户模式</strong>或<strong>子模式</strong>，对应于<strong>视图层</strong>数据抽象，是数据库用户（程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是<strong>数据库用户的数据视图</strong></li><li>用户只能看见和访问<strong>对应的外模式</strong>中的数据，<strong>其余数据则不可见</strong> <br></li></ul></li><li><p><strong>模式</strong></p><ul><li>也称为<strong>逻辑模式</strong>，对应于<strong>逻辑层</strong>数据抽象，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图</li><li>与硬件、应用程序、开发工具和高级程序设计语言无关</li></ul></li><li><p><strong>内模式</strong></p><ul><li>也称<strong>存储模式</strong>，是数据的物理结构和存储方式的描述，是数据在数据库内部的表示方式</li></ul></li></ol><h3 id="两层映像">3. 两层映像</h3><p><strong>作用</strong>：保证DBMS中的数据能够具有较高的逻辑独立性和物理独立性。</p><ol type="1"><li><p><strong>外模式/模式映像</strong></p><ul><li>定义了该外模式与模式之间的对应关系</li><li>一个模式（全局）可以有多个外模式(局部)</li><li>保证数据与应用程序的<strong>逻辑独立性</strong></li></ul></li><li><p><strong>模式/内模式映像</strong></p><ul><li>定义了数据全局逻辑结构与存储结构之间的对应关系</li><li>数据库中仅有一个内模式和一个模式，故<strong>模式/内模式映像是唯一的</strong></li><li>保证数据与应用程序的<strong>物理独立性</strong></li></ul></li></ol><h3 id="数据抽象三层模型与三级模式与的关系">4. 数据抽象、三层模型与三级模式与的关系</h3><p>数据抽象是在不同的层次之间提供概念上的统一，使得不同层次的应用程序可以通过抽象层进行交互，而不必关心底层的实现细节。</p><p>三级模式描述了数据库系统的三个不同层次的逻辑结构，而三层模型是对三级模式的抽象和概括，分别对应了不同的层次：用户层、逻辑层和物理层。</p><p>三级模式更加关注于数据库的逻辑结构，而三层模型则更加关注于不同层次之间的关系和交互。三层模型的出现是为了方便不同层次之间的交互和协作，使得数据管理更加高效、灵活、易于扩展。</p><figure><img src="img/post/20230223/%E8%81%94%E7%B3%BB.png" alt="" /><figcaption>联系</figcaption></figure><h2 id="六数据库系统与数据库管理系统">六、数据库系统与数据库管理系统</h2><h3 id="数据库系统">1. 数据库系统</h3><p><strong>数据库系统（DBS）</strong> 是指在计算机系统中引入数据库后的系统，一般由<strong>数据库</strong>、<strong>数据库管理系统</strong>、<strong>应用系统</strong>、<strong>数据库管理员</strong>和<strong>最终用户</strong>构成。</p><h3 id="数据库管理系统">2. 数据库管理系统</h3><p><strong>数据库管理系统（DBMS）</strong> 是一组负责数据库的访问、管理和控制的软件，用以完成用户对数据库的各种操作请求。</p><ol type="1"><li><p><strong>DBMS的功能</strong></p><ul><li>数据定义</li><li>数据组织、存储和管理</li><li>数据操纵</li><li>数据库的事物管理和运行管理</li><li>数据库的建立和维护等</li></ul></li><li><p><strong>DBMS的组成</strong></p><figure><img src="img/post/20230223/DBMS%E7%BB%84%E6%88%90.png" alt="" /><figcaption>DBMS组成</figcaption></figure><p>其中：</p><ul><li><strong>模式更新</strong>：对数据库的逻辑结构进行修改，如在一张表中增加一列属性</li><li><strong>查询处理器</strong>：对用户请求的SQL操作进行查询优化，或更新数据库中相应的数据</li><li><strong>事务管理器</strong>：负责资源管理，事务调度，保证数据库的一致性，保证多个同时运行的事务不冲突，以及保证当系统故障时数据不丢失</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库，笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Kotlin】学习笔记（四）集合类</title>
    <link href="/2023/02/04/kotlin/kotlin-20230204/"/>
    <url>/2023/02/04/kotlin/kotlin-20230204/</url>
    
    <content type="html"><![CDATA[<h2 id="一list">一、List</h2><p>在Java中，我们可以使用ArraryList，当然在Kotlin中也可以这么做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list1 = ArraryList&lt;String&gt;()<br>list1.add(<span class="hljs-string">&quot;Apple&quot;</span>)<br>list1.add(<span class="hljs-string">&quot;Banana&quot;</span>)<br>list1.add(<span class="hljs-string">&quot;Pear&quot;</span>)<br></code></pre></td></tr></table></figure><p>Kotlin中提供了两种内置函数 <code>listOf()</code> 和 <code>mutableListOf()</code> 来简化初始化List的写法。</p><p>前者创建的List不可修改，而后者可修改：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list1 = listOf(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>)<br><span class="hljs-comment">//list1.add(&quot;Grape&quot;) //报错</span><br><br><span class="hljs-keyword">val</span> list2 = mutableListOf(<span class="hljs-string">&quot;Kim&quot;</span>, <span class="hljs-string">&quot;Sam&quot;</span>, <span class="hljs-string">&quot;Lisa&quot;</span>)<br>list2.add(<span class="hljs-string">&quot;Jack&quot;</span>) <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p>我们可以用<code>for-in</code>循环遍历这些集合</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> (fruit <span class="hljs-keyword">in</span> list1) &#123;<br>    println(fruit)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二set">二、Set</h2><p>Set集合与List集合的用法相近，只是Set集合不能存放重复元素。</p><p>Kotlin中同样提供了两种内置函数 <code>setOf()</code> 和 <code>mutableSetOf()</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> <span class="hljs-keyword">set</span> = mutableSetOf(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>)<br><span class="hljs-keyword">set</span>.add(<span class="hljs-string">&quot;Apple&quot;</span>) <span class="hljs-comment">//重复元素，不添加</span><br><span class="hljs-keyword">set</span>.add(<span class="hljs-string">&quot;Grape&quot;</span>) <span class="hljs-comment">//非重复，添加成功</span><br><span class="hljs-keyword">for</span> (fruit <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>) &#123;<br>    println(fruit)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三map">三、Map</h2><p>与其他语言一样，Map是一种以键值对形式的的数据结构，Java中的通常做法是创建一个HashMap实例，用<code>put()</code>和<code>get()</code>去操作这个Map：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> map1 = HashMap&lt;String, <span class="hljs-built_in">Int</span>&gt;()<br>map1.put(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-number">1</span>)<br>map1.put(<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-number">2</span>)<br>map1.put(<span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>在Kotlin中，我们也可以使用类似JavaScript的下标语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">map1[<span class="hljs-string">&quot;Grape&quot;</span>] = <span class="hljs-number">4</span><br><span class="hljs-keyword">val</span> num = map1[<span class="hljs-string">&quot;Apple&quot;</span>]<br></code></pre></td></tr></table></figure><p>当然，Kotlin中也提供了 <code>mapOf()</code> 和 <code>mutableMapOf()</code>来简化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> map1 = mapOf(<br>    <span class="hljs-string">&quot;Apple&quot;</span>     to <span class="hljs-number">1</span><br>    <span class="hljs-string">&quot;Banana&quot;</span>    to <span class="hljs-number">2</span><br>    <span class="hljs-string">&quot;Pear&quot;</span>      to <span class="hljs-number">3</span><br>)<br></code></pre></td></tr></table></figure><p>其中的 <strong>to</strong> 并不是关键字，而是一个 <strong>infix函数</strong>。</p><p>同样，可以使用for循环去遍历Map</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> ((fruit, number) <span class="hljs-keyword">in</span> map1) &#123;<br>    println(<span class="hljs-string">&quot;fruit is &quot;</span> + fruit + <span class="hljs-string">&quot;, number is &quot;</span> + number)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四集合常用lambda操作">四、集合常用lambda操作</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> li = listOf(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br><br><span class="hljs-keyword">val</span> a = li.maxBy&#123;it&#125;        <span class="hljs-comment">//最大值，同理有minBy</span><br>println(<span class="hljs-string">&quot;maxBy: %a&quot;</span>)        <span class="hljs-comment">// 5</span><br><br><span class="hljs-keyword">val</span> b = li.filter&#123;it &gt; <span class="hljs-number">3</span>&#125;   <span class="hljs-comment">// 过滤器</span><br>println(<span class="hljs-string">&quot;filter: &quot;</span>)<br><span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> b) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$n</span> &quot;</span>)            <span class="hljs-comment">// 5 4</span><br>&#125;<br>println()<br><br><span class="hljs-keyword">val</span> c = li.sortedBy&#123;it&#125;     <span class="hljs-comment">// 升序排序，加-号为降序</span><br>println(<span class="hljs-string">&quot;sortBy: &quot;</span>)<br><span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> c) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$n</span> &quot;</span>)            <span class="hljs-comment">// 1 2 3 4 5</span><br>&#125;<br>println()<br><br><span class="hljs-keyword">val</span> d = li.map&#123;it * <span class="hljs-number">2</span>&#125;      <span class="hljs-comment">//将集合内的值改为另一个值</span><br>println(<span class="hljs-string">&quot;map: &quot;</span>)<br><span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> d) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$n</span> &quot;</span>)            <span class="hljs-comment">// 2 6 10 4 8</span><br>&#125;<br>println()<br><br><span class="hljs-keyword">val</span> e = li.mapIndexed&#123;      <span class="hljs-comment">//同上，但lambda参数带下标</span><br>    index, value -&gt; index * value<br>&#125;      <br>println(<span class="hljs-string">&quot;map: &quot;</span>)<br><span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> e) &#123;<br>    print(<span class="hljs-string">&quot;<span class="hljs-variable">$n</span> &quot;</span>)            <span class="hljs-comment">// 0 3 10 6 16 </span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
      <tag>笔记</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Kotlin】学习笔记（三）Lambda表达式</title>
    <link href="/2023/02/03/kotlin/kotlin-20230203/"/>
    <url>/2023/02/03/kotlin/kotlin-20230203/</url>
    
    <content type="html"><![CDATA[<h2 id="lambda变量">1.Lambda变量</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sum = &#123;a: <span class="hljs-built_in">Int</span>, b: <span class="hljs-built_in">Int</span> -&gt; <br>    a + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(sum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lambda表达式作为参数匿名函数">2.Lambda表达式作为参数（匿名函数）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transform</span><span class="hljs-params">(arr: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Int</span>&gt;, action: (<span class="hljs-type">index</span>: <span class="hljs-type">Int</span>, <span class="hljs-type">ele</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-comment">//遍历下标集</span><br>    <span class="hljs-keyword">for</span> (index <span class="hljs-keyword">in</span> arr.indices) &#123;<br>        <span class="hljs-keyword">val</span> newValue = action(index, arr[index])<br>        arr[index] = newValue<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> numbers = arrayOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>    <span class="hljs-comment">//传入Lambda: 将数组的每个元素与其下标相乘</span><br>    <span class="hljs-comment">//效果与 numbers.mapIndexed&#123;index, value -&gt; index * value&#125; 相当</span><br>    transform(numbers, &#123;index, ele -&gt; <br>        index * ele<br>    &#125;)<br>    <br>    <span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> numbers) &#123;<br>        println(n)<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进阶语法">3.进阶语法</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fun1</span><span class="hljs-params">(action: (<span class="hljs-type">a</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>&#123;<br>    println(action(<span class="hljs-number">3</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 原表达式</span><br>    fun1(&#123;value:<span class="hljs-built_in">Int</span> -&gt; value * value&#125;)<br><br>    <span class="hljs-comment">// 1.由于可以自动推导类型，故省略类型声明</span><br>    fun1(&#123;value -&gt; value * value&#125;)<br><br>    <span class="hljs-comment">// 2.当lambda表达式是函数中最后一个参数时，可以将其放在函数后面</span><br>    fun1()&#123;value -&gt; value * value&#125;<br><br>    <span class="hljs-comment">// 3.当函数括号内没有参数时，可以省略括号</span><br>    fun1&#123;value -&gt; value * value&#125;<br><br>    <span class="hljs-comment">// 4.当lambda表达式参数只有一个时，可以省略，改用it指代</span><br>    fun1&#123;it * it&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
      <tag>笔记</tag>
      
      <tag>Lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Kotlin】学习笔记（二）面向对象编程</title>
    <link href="/2023/02/02/kotlin/kotlin-20230202/"/>
    <url>/2023/02/02/kotlin/kotlin-20230202/</url>
    
    <content type="html"><![CDATA[<h2 id="一类与对象">一、类与对象</h2><p>下面的将示范如何创建一个Kotlin类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;      <span class="hljs-comment">//类名：Person</span><br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span>   <span class="hljs-comment">//类成员变量</span><br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">//类成员函数</span><br>        println(name + <span class="hljs-string">&quot;，&quot;</span> + age + <span class="hljs-string">&quot;岁&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将这个类进行<strong>实例化</strong>，获得一个<strong>对象</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> p = Person() <span class="hljs-comment">//跟Java相比，去掉了new关键字</span><br>    p.name = <span class="hljs-string">&quot;田所浩二&quot;</span><br>    p.age = <span class="hljs-number">24</span><br>    p.show()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二类的继承与构造函数">二、类的继承与构造函数</h2><p>首先，在Kotlin中，所有非抽象类默认都是不可继承的，就像Java中的<code>final</code>声明的类，要使得类能悲继承，需要<code>open</code>关键字。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;      <span class="hljs-comment">//类名：Person</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们让<code>Student</code>类继承<code>Person</code>类，使用一个冒号，注意被继承类名后面的括号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-type">Person</span>() &#123;<br>    <span class="hljs-keyword">var</span> id = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> grade = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外是关于构造函数的部分。Kotlin将构造函数分成了两种：<strong>主构造函数</strong>和<strong>次构造函数</strong>。</p><h3 id="主构造函数">1.主构造函数</h3><p><strong>主构造函数</strong>是每个类默认都会有的一个不带参数的构造函数，我们也可以给它指定参数。主构造函数没有函数体，直接定义在类名后面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> id: String, <span class="hljs-keyword">val</span> grade: <span class="hljs-built_in">Int</span>): Person() &#123;<br>    <span class="hljs-comment">//在主构造函数中声明为val或var的参数会自动成为该类的成员</span><br>&#125;<br><br><span class="hljs-comment">//实例化的时候：传入构造函数的所有参数：</span><br><span class="hljs-keyword">val</span> student = Student(<span class="hljs-string">&quot;1145141919810&quot;</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>主构造函数没有函数体，如果想在其中编写逻辑，可以使用init结构体：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> id: String, <span class="hljs-keyword">val</span> grade: <span class="hljs-built_in">Int</span>): Person() &#123;<br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;id is &quot;</span> + id)<br>        println(<span class="hljs-string">&quot;grade is &quot;</span> + grade)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据继承的规定，<strong>子类的构造函数必须调用父类的构造函数</strong>，我们就需要在括号中填入父类构造函数的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//将Person类的主构造函数改为：</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//将Student类的继承改为：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> id: String, <span class="hljs-keyword">val</span> grade: <span class="hljs-built_in">Int</span>, name: String, age: <span class="hljs-built_in">Int</span>): <br>    Person(name, age) &#123; <span class="hljs-comment">//这里的name, age仅作为参数，不生成成员字段，防止父类同名成员的冲突</span><br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;id is &quot;</span> + id)<br>        println(<span class="hljs-string">&quot;grade is &quot;</span> + grade)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="次构造函数">2.次构造函数</h3><p>一个类能有多个次构造函数，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> id: String, <span class="hljs-keyword">val</span> grade: <span class="hljs-built_in">Int</span>, name: String, age: <span class="hljs-built_in">Int</span>): <br>    Person(name, age) <br>&#123; <br>    <br>    <span class="hljs-keyword">constructor</span>(name: String, age: <span class="hljs-built_in">Int</span>): <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, name, age) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">constructor</span>(): <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>) &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">val</span> st1 = Student()<br><span class="hljs-keyword">val</span> st2 = Student(<span class="hljs-string">&quot;我修院卓&quot;</span>, <span class="hljs-number">23</span>)<br><span class="hljs-keyword">val</span> st3 = Student(<span class="hljs-string">&quot;1145141919810&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;田所浩二&quot;</span>, <span class="hljs-number">24</span>)<br></code></pre></td></tr></table></figure><p>如果类中<strong>没有主构造函数，只有次构造函数</strong>该怎么继承？代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-type">Person</span> &#123; <span class="hljs-comment">//没有主构造，故不用写括号</span><br>    <span class="hljs-comment">//以super关键字直接调用父类构造函数</span><br>    <span class="hljs-keyword">constructor</span>(name: String, age: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">super</span>(name, age) &#123;&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三接口">三、接口</h2><p>不同于C++的多继承，Java和Kotlin都是单继承结构的语言，最多只允许继承一个父类，但可以实现任意个<strong>接口</strong> 接口中定义的函数可以不实现，也可以定义默认的实现。Kotlin只会强制要求实现没有默认实现的函数。 接口定义方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readBooks</span><span class="hljs-params">()</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doHomework</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;doing homework&quot;</span>) <span class="hljs-comment">//默认的实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>让<code>Student</code>类实现这个接口, 和继承的写法一样，然后再使用<code>override</code>关键字重载接口定义的函数:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(name: String, age: <span class="hljs-built_in">Int</span>) : Person(name, age), Study &#123; <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readBooks</span><span class="hljs-params">()</span></span> &#123;<br>        println(name + <span class="hljs-string">&quot; is reading.&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doHomework</span><span class="hljs-params">()</span></span> &#123;<br>        println(name + <span class="hljs-string">&quot; is doing homework&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//使用这个类:</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> stu = Student(<span class="hljs-string">&quot;田所浩二&quot;</span>, <span class="hljs-number">24</span>)<br>    doStudy(stu)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doStudy</span><span class="hljs-params">(stu: <span class="hljs-type">Study</span>)</span></span> &#123; <br>    <span class="hljs-comment">//只有继承了Study接口的类的对象才能使用该函数</span><br>    stu.readBooks()<br>    stu.doHomework()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四可见性修饰符">四、可见性修饰符</h2><p>Java中有四种修饰符：<code>public</code>、<code>private</code>、<code>protected</code>、<code>default</code>，默认是<code>default</code>。</p><p>Kotlin也有四种：<code>public</code>、<code>private</code>、<code>protected</code>、<code>internal</code>， 默认是<code>public</code>。</p><table><thead><tr class="header"><th>修饰符</th><th>Java</th><th>Kotlin</th></tr></thead><tbody><tr class="odd"><td>public</td><td>所有类可见</td><td>所有类可见(默认)</td></tr><tr class="even"><td>private</td><td>当前类可见</td><td>当前类可见</td></tr><tr class="odd"><td>protected</td><td>当前类、子类、同一煲路径下的类可见</td><td>当前类，子类可见</td></tr><tr class="even"><td>default</td><td>同一包路径下的类可见(默认)</td><td>无</td></tr><tr class="odd"><td>internal</td><td>无</td><td>同一模块中的类可见</td></tr></tbody></table><h2 id="五数据类">五、数据类</h2><p>在一个规范的系统架构中，<strong>数据类</strong>用于将服务器端或数据库中的数据映射到内存中，为编程逻辑提供数据模型的支持。</p><p>在Java中数据类通常需要重写<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>这几个方法，而Kotlin则只需要一个<code>data</code>关键字，这些方法便会自动生成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cellphone</span>(<span class="hljs-keyword">val</span> brand: String, <span class="hljs-keyword">val</span> price: <span class="hljs-built_in">Double</span>)<br></code></pre></td></tr></table></figure><p>当一个类内部没有任何代码，便可以将大括号省略。 下面测试一下这个数据类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> cellphone1 = Cellphone(<span class="hljs-string">&quot;Samsung&quot;</span>, <span class="hljs-number">1299.99</span>)<br>    <span class="hljs-keyword">val</span> cellphone2 = Cellphone(<span class="hljs-string">&quot;Samsung&quot;</span>, <span class="hljs-number">1299.99</span>)<br>    println(cellphone1)<br>    println(<span class="hljs-string">&quot;cellphone1 == cellphone2 ? &quot;</span> + (cellphone1 == cellphone2))<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><pre><code class="hljs">Cellphone(brand=Samsung, price=1299.99)cellphone1 == cellphone2 ? true</code></pre><h2 id="六单例类">六、单例类</h2><p>使用单例可以避免创建重复的对象，保证一个类最多拥有一个实例。</p><p>在<strong>Java</strong>中创建单例类需要以下几个步骤：</p><ol type="1"><li>将类的<strong>构造函数私有化</strong></li><li>向外部提供一个<code>getInstance()</code>的<strong>静态方法</strong>用于获取该类实例</li><li>在<code>getInstance()</code>中，判断如果当前缓存的实例为<code>null</code>，就创建一个新的实例并将其缓存，否则直接返回缓存的实例即可。</li></ol><p>在<strong>Kotlin</strong>中，只需要将<code>class</code>关键字改成<code>object</code>关键字即可声明单例类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> Singleton &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;test is called&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//调用方式</span><br>Singleton.test()<br></code></pre></td></tr></table></figure><p>看上去就像是调用了静态方法，其实是Kotlin在背后自动创建了一个类的实例，并且保证全局只有一个该类的实例。</p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
      <tag>笔记</tag>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Kotlin】学习笔记（一）变量、函数与逻辑控制</title>
    <link href="/2023/02/01/kotlin/kotlin-20230201/"/>
    <url>/2023/02/01/kotlin/kotlin-20230201/</url>
    
    <content type="html"><![CDATA[<h2 id="一变量">一、变量</h2><h3 id="定义方法">1.定义方法</h3><p>在Kotlin中，我们使用关键字<code>val</code>或<code>var</code>来声明一个变(常)量。</p><pre><code class="hljs">val: 声明一个常量，相当于java中的final变量，无法二次赋值var: 声明一个变量</code></pre><p>用例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = <span class="hljs-number">114</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">5.14</span><br></code></pre></td></tr></table></figure><p>Kotlin具备优秀的类型推导能力，它会将a的类型推导为Int，并将b的类型推导为Double。</p><h3 id="变量类型">2.变量类型</h3><p>例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a : <span class="hljs-built_in">Int</span> = <span class="hljs-number">114514</span> <span class="hljs-comment">//正确</span><br><span class="hljs-keyword">val</span> b : <span class="hljs-built_in">Int</span> = <span class="hljs-number">1919.810</span> <span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><p>Kotlin部分的对象数据类型如下： |类型对象|名称| |----|----| |Int|整形| |Long|长整型| |Short|短整型| |Float|单精度浮点型| |Double|双精度浮点型| |Boolean|布尔型| |Char|字符型| |Byte|字节型| |Number|数值型| |String|字符串型|</p><h2 id="二函数">二、函数</h2><h3 id="基本定义">1.基本定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> 函数名<span class="hljs-params">(参数a: 类型<span class="hljs-type">a</span>，参数<span class="hljs-type">b</span>: 类型<span class="hljs-type">b</span>)</span></span>: 返回值类型 &#123;<br>    <span class="hljs-keyword">return</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><p>特别地，当函数中只有一行代码时，可以不写花括号 <code>&#123;&#125;</code>，而使用 <code>=</code> 进行简化。如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>, num2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = max(num1, num2)<br></code></pre></td></tr></table></figure><p>在这种写法下，还能省去返回值类型的声明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largeNumber</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>, num2: <span class="hljs-type">Int</span>)</span></span> = max(num1, num2)<br></code></pre></td></tr></table></figure><p>另外，函数中声明的参数默认是可变的，如果想让它不可更改，可以在前面添加关键字<code>val</code></p><h2 id="三逻辑控制">三、逻辑控制</h2><h3 id="if语句">1.if语句</h3><p>和大部分语言中的<code>if</code>基本没有区别</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">4</span><br><span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>    a = b<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b &gt; a)&#123;<br>    b = a<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    a = <span class="hljs-number">9</span><br>    b = <span class="hljs-number">9</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但在Kotlin中，<code>if</code>语句还有别的功能: 具有返回值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largerNumber</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>, num2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">val</span> value = <span class="hljs-keyword">if</span> (num1 &gt; num2) &#123; num1 &#125; <span class="hljs-keyword">else</span> &#123; num2 &#125;<br>    <span class="hljs-keyword">return</span> value<br>&#125;<br><br><span class="hljs-comment">//继续简化：</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largerNumber</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>, num2: <span class="hljs-type">Int</span>)</span></span> = <span class="hljs-keyword">if</span> (num1 &gt; num2) &#123;<br>    num1 <br>&#125; <span class="hljs-keyword">else</span> &#123; <br>    num2 <br>&#125;<br><br><span class="hljs-comment">//再简化：</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">largerNumber</span><span class="hljs-params">(num1: <span class="hljs-type">Int</span>, num2: <span class="hljs-type">Int</span>)</span></span> = <span class="hljs-keyword">if</span> (num1 &gt; num2) num1 <span class="hljs-keyword">else</span> num2<br><br></code></pre></td></tr></table></figure><h3 id="when语句">2.when语句</h3><p><code>when</code>语句类似Java中的<code>switch</code>，但更加完善、简洁</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScore</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = <span class="hljs-keyword">when</span>(name) &#123;<br>    <span class="hljs-string">&quot;Tom&quot;</span> -&gt; <span class="hljs-number">86</span><br>    <span class="hljs-string">&quot;Jim&quot;</span> -&gt; <span class="hljs-number">77</span><br>    <span class="hljs-string">&quot;Jack&quot;</span> -&gt; <span class="hljs-number">95</span><br>    <span class="hljs-keyword">else</span> -&gt; &#123;<br>        println(<span class="hljs-string">&quot;Error&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，可以不在<code>when</code>中传入参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScore</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = <span class="hljs-keyword">when</span> &#123;<br>    name == <span class="hljs-string">&quot;Tom&quot;</span> -&gt; <span class="hljs-number">86</span>  <span class="hljs-comment">//不需要像Java那样使用 .equal() 对字符串进行判断</span><br>    name == <span class="hljs-string">&quot;Jim&quot;</span> -&gt; <span class="hljs-number">77</span><br>    name.startWith(<span class="hljs-string">&quot;Jack&quot;</span>) -&gt; <span class="hljs-number">95</span> <span class="hljs-comment">//箭头的左边可以换成所有带布尔返回值的表达式</span><br>    <span class="hljs-keyword">else</span> -&gt; &#123;<br>        println(<span class="hljs-string">&quot;Error&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>when语句还支持类型匹配：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkNumber</span><span class="hljs-params">(num: <span class="hljs-type">Number</span>)</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (num) &#123;<br>        <span class="hljs-keyword">is</span> <span class="hljs-built_in">Int</span> -&gt; println(<span class="hljs-string">&quot;num is Int&quot;</span>)<br>        <span class="hljs-keyword">is</span> <span class="hljs-built_in">Double</span> -&gt; println(<span class="hljs-string">&quot;num is Double&quot;</span>)<br>        <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;num not support&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for循环">3.for循环</h3><p>首先，Kotlin中移除了<code>for-i</code>循环，但加强了<code>for-each</code>循环。还引入了<strong>区间</strong>的概念。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> range1 = <span class="hljs-number">0.</span><span class="hljs-number">.10</span>              <span class="hljs-comment">//表示[0,10]的整数数组，双端闭区间</span><br><span class="hljs-keyword">val</span> range2 = <span class="hljs-number">0</span> until <span class="hljs-number">10</span>         <span class="hljs-comment">//表示[0,10)，左闭右开</span><br><span class="hljs-keyword">val</span> range3 = <span class="hljs-number">0</span> until <span class="hljs-number">10</span> step <span class="hljs-number">2</span>  <span class="hljs-comment">//step关键字，设置递增</span><br></code></pre></td></tr></table></figure><p><code>..</code> 和 <code>until</code>都要符合左端小于等于右端，无法创造递减区间。 如果要创造一个降序区间，要使用关键字 <code>downTo</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> range4 = <span class="hljs-number">10</span> downTo <span class="hljs-number">1</span>        <span class="hljs-comment">//[10,1]的降序区间，双端闭区间</span><br></code></pre></td></tr></table></figure><p>有了区间之后，就可以通过<code>for-in</code>循环来遍历这个区间：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.10</span>) &#123; <span class="hljs-comment">//在for循环中定义的循环变量无需使用var或val关键字</span><br>    println(i)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="while循环">4.while循环</h3><p>Kotlin中的<code>while</code>循环和Java中的没有任何区别：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) &#123;<br>    i++<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，<code>do-while</code>循环也一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br><span class="hljs-keyword">do</span>&#123;<br>    i++<br>&#125;<span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">10</span>)<br>println(i)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
      <tag>笔记</tag>
      
      <tag>变量</tag>
      
      <tag>函数</tag>
      
      <tag>逻辑控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于该博客的评论区</title>
    <link href="/2023/01/12/other-20230112/"/>
    <url>/2023/01/12/other-20230112/</url>
    
    <content type="html"><![CDATA[<p>本博客由 <a href="valine.js.org">Valine</a> 提供的评论区支持，依赖 <a href="https://en.gravatar.com/">Gravatar</a> 头像服务。评论时<strong>必须</strong>填入昵称。另外，填写注册过Gravatar的邮箱即可显示自定义头像。</p><p><strong>大致使用流程：</strong></p><ol type="1"><li><p>注册：进入 <a href="https://en.gravatar.com/">Gravatar</a> 网站，点击页面的Sign Up进行注册。</p></li><li><p>验证：进入你的邮箱，从Gravatar发出的信件中拷贝那段链接地址，在浏览器输入。</p></li><li><p>设置昵称、密码。</p></li><li><p>选择上传图片：一般都是从电脑中上传（My computer’s hard drive）。</p></li><li><p>剪裁大小</p></li><li><p>评级：你的头像要被分级的，因为可能会有朋友喜欢用比较曝露的头像，会影响小朋友身心健康的说。如果你的图片不是特别那个的话，一般不用选择Sex或暴力之类的，直接选择G（通用型），这样基本任何网站都能显示这个等级的图片。异次元比较邪恶，暂时允许显示R级以下的头像…</p></li><li><p>等待审核：可能需要站方短暂审核一下，一般选择了G，而你的图片没什么特别的，很快就通过。一般遇上慢的情况也就10分钟左右。</p></li></ol><p>完成了以上步骤，今后在支持Gravatar的网站留言都会显示你帅帅的头像了。</p><p>原文链接：<a href="https://blog.csdn.net/z_johnny/article/details/104211572/" class="uri">https://blog.csdn.net/z_johnny/article/details/104211572/</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>评论</tag>
      
      <tag>头像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】人物跳跃卡墙Bug的解决方法</title>
    <link href="/2023/01/12/unity/unity-20230112/"/>
    <url>/2023/01/12/unity/unity-20230112/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>发现人物在跳跃时如果碰到墙壁，会卡住不动。</p><figure><img src="img/post/20230112/01-smil.png" alt="" /><figcaption>卡墙</figcaption></figure><p>原因是人物的RigidBody没有物理材质，导致其产生的摩擦力无限大，造成了卡墙现象</p><figure><img src="img/post/20230112/02-smil.png" alt="" /><figcaption>人物的RigidBody2D</figcaption></figure><h2 id="问题解决">问题解决</h2><p>给人物设置两个物理材质，一个有摩擦，一个无摩擦。</p><p>在人物跳跃时切换无摩擦材质，其他情况切换有摩擦的材质。</p><figure><img src="img/post/20230112/03-smil.png" alt="" /><figcaption>两种材质</figcaption></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//物理材质</span><br><span class="hljs-keyword">public</span> PhysicsMaterial2D pm_normal; <br><span class="hljs-keyword">public</span> PhysicsMaterial2D pm_jump; <span class="hljs-comment">//跳跃时切换无摩擦力，防止卡墙</span><br><br><span class="hljs-keyword">private</span> RigidBody2D rig;<br>...<br><span class="hljs-keyword">if</span> (落地条件) &#123;<br>    rig.sharedMaterial = pm_normal;<br>&#125;<br><br><span class="hljs-keyword">if</span> (跳跃条件) &#123;<br>    rig.sharedMaterial = pm_jump;<br>&#125;<br></code></pre></td></tr></table></figure><p>挺取巧的一个办法，就当作是简单的补丁先用着吧。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>跳跃</tag>
      
      <tag>卡墙</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Unity】因使用混合树而导致的奇怪Bug(已修复)</title>
    <link href="/2023/01/11/unity/unity-20230111/"/>
    <url>/2023/01/11/unity/unity-20230111/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>今天使用Unity时发现：<strong>物体没有按照动画设置的参数运动</strong>。</p><p>我为人物设置了攻击动画，由于人物不对称，故左右独立设置。如图是其中一段动画，其中设置了攻击区域触发器的变化动画。</p><span id="more"></span><figure><img src="img/post/20230111/01-smil.png" alt="" /><figcaption>应当正确显示的情况</figcaption></figure><p>但当我运行时，<strong>攻击区域触发器却发生了奇怪的位移</strong>，跟动画clip中的设置不一致。</p><figure><img src="img/post/20230111/02-smil.png" alt="" /><figcaption>运行后发现攻击触发器的位置不正确</figcaption></figure><p></br></p><h2 id="问题排查">问题排查</h2><p>经过2小时的折磨，在同学的帮助下终于锁定问题关键：</p><table><thead><tr class="header"><th><img src="img/post/20230111/03-smil.png" alt="03.jpg" /></th><th><img src="img/post/20230111/05-smil.png" alt="05.jpg" /></th></tr></thead><tbody></tbody></table><p>我使用了 <strong>混合树</strong> 来控制人物的左右攻击，恰恰就是这个混合树出了问题。</p><p>结论就是：<strong>混合树将我的左右两个动画的攻击区域触发器的各项参数进行混合，其中就包括了触发器形状的offset</strong>！这导致两个动画各自触发器形状的offset叠加而抵消，使其最后显示的<strong><em>offset的x值始终在0附近</em></strong>。</p><p></br></p><h2 id="问题解决">问题解决</h2><p>最后简单粗暴地解决了：放弃使用混合树控制左右动画。经过检验这样是可行的。</p><figure><img src="img/post/20230111/04-smil.png" alt="" /><figcaption>弃用混合树</figcaption></figure><p>原本我使用混合树仅仅只是想优化一下拓扑结构。。。现在不能这么玩了。</br></p><p>我创建了子状态机，然后把攻击动画的逻辑全塞里面。。。让他看起来。。额。。至少没这么复杂(大概)。</p><table><thead><tr class="header"><th><img src="img/post/20230111/06-smil.png" alt="06.jpg" /></th><th><img src="img/post/20230111/07-smil.png" alt="07.jpg" /></th></tr></thead><tbody></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Bug</tag>
      
      <tag>混合树</tag>
      
      <tag>动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
